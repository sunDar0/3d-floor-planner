<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple Floor Planner</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #f3f4f6;
    }

    canvas {
      display: block;
    }

    .canvas-container {
      cursor: crosshair;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.05);
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import {
      GRID_SIZE, VISUAL_GRID_SIZE, WALL_THICKNESS, WALL_HEIGHT,
      DOOR_WIDTH, DOOR_HEIGHT, WINDOW_WIDTH, WINDOW_HEIGHT, WINDOW_SILL,
      BALCONY_WIDTH, BALCONY_HEIGHT, HEIGHT_MALE, HEIGHT_FEMALE,
      TOOLS, FURNITURE_CATEGORIES, FURNITURE_TEMPLATES
    } from './src/config/constants.js';

    import { snapToGrid, distance, projectPointOnLine } from './src/utils/geometry.js';
    import { getSnappedPosition } from './src/utils/snap.js';
    import { checkCollision } from './src/utils/collision.js';
    import { createFloorTexture, createWallTexture, createCeilingTexture } from './src/rendering/textures.js';
    import { drawRoom, drawWall, drawOpening, drawFurniture, drawGrid } from './src/rendering/canvas2d.js';
    import { createRoomObjects, createWallObjects } from './src/rendering/sceneBuilder.js';
    import { createFurnitureGroup } from './src/rendering/furnitureBuilder.js';
    import { downloadFloorPlan, uploadFloorPlan } from './src/utils/fileHandler.js';
    import { useHistory } from './src/hooks/useHistory.js';

    const { useState, useEffect, useRef, useMemo, useCallback } = React;
    const { OrbitControls, PointerLockControls } = THREE;

    // ì„¤ì • ê°’
    // ìœ í‹¸ë¦¬í‹° ë° ìƒìˆ˜ëŠ” import ë¨


    // --- 3D ë·°ì–´ ì»´í¬ë„ŒíŠ¸ ---
    const Viewer3D = ({ walls, rooms, openings, furniture = [] }) => {
      const mountRef = useRef(null);
      const [isFPV, setIsFPV] = useState(false);
      const [gender, setGender] = useState('male'); // 'male' | 'female'
      const [isLocked, setIsLocked] = useState(false);

      // Refs for animation loop access
      const sceneRef = useRef(null);
      const cameraRef = useRef(null);
      const rendererRef = useRef(null);
      const controlsRef = useRef(null);
      const fpvControlsRef = useRef(null);
      const requestRef = useRef(null);
      const doorsRef = useRef([]); // ë¬¸ ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•œ ì°¸ì¡°
      const ceilingsRef = useRef([]); // ì²œì¥ ë©”ì‰¬ ì°¸ì¡°

      // Movement state
      const moveState = useRef({
        forward: false,
        backward: false,
        left: false,
        right: false,
        velocity: new THREE.Vector3(),
        direction: new THREE.Vector3()
      });

      // useMemoë¡œ í…ìŠ¤ì²˜ ë° ì¬ì§ˆ ìºì‹±
      const floorTexture = useMemo(() => createFloorTexture(), []);
      const wallTexture = useMemo(() => createWallTexture(), []);

      const floorMaterial = useMemo(() => new THREE.MeshStandardMaterial({
        map: floorTexture,
        roughness: 0.8,
        metalness: 0.1,
        side: THREE.DoubleSide
      }), [floorTexture]);

      const wallMaterial = useMemo(() => new THREE.MeshStandardMaterial({
        map: wallTexture,
        roughness: 0.9,
        color: 0xffffff
      }), [wallTexture]);

      const ceilingTexture = useMemo(() => createCeilingTexture(), []);
      const ceilingMaterial = useMemo(() => new THREE.MeshStandardMaterial({
        map: ceilingTexture,
        roughness: 0.9,
        side: THREE.DoubleSide // ì–‘ë©´ ë Œë”ë§ (ìœ„ì—ì„œ ë´ë„, ì•„ë˜ì„œ ë´ë„)
      }), [ceilingTexture]);

      // ì¶©ëŒ ê°ì§€ í•¨ìˆ˜ (Imported Wrapper)
      const checkPlayerCollision = (x, z) => {
        return checkCollision(x, z, walls, openings);
      };

      useEffect(() => {
        if (!mountRef.current) return;

        // Scene Setup
        doorsRef.current = []; // ì´ˆê¸°í™”
        ceilingsRef.current = []; // ì´ˆê¸°í™”
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0f2fe); // í•˜ëŠ˜ìƒ‰ ë°°ê²½
        scene.fog = new THREE.Fog(0xe0f2fe, 500, 3000); // ì•ˆê°œ íš¨ê³¼ë¡œ ê¹Šì´ê° ì¶”ê°€
        sceneRef.current = scene;

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 5000);
        cameraRef.current = camera;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight - 80);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ë¶€ë“œëŸ¬ìš´ ê·¸ë¦¼ì
        mountRef.current.appendChild(renderer.domElement);
        rendererRef.current = renderer;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.3);
        hemiLight.position.set(0, 200, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(500, 1500, 1000);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 5000;
        dirLight.shadow.camera.left = -1500;
        dirLight.shadow.camera.right = 1500;
        dirLight.shadow.camera.top = 1500;
        dirLight.shadow.camera.bottom = -1500;
        dirLight.shadow.bias = -0.0001;
        scene.add(dirLight);



        // Ground (ì™¸ë¶€ ë°”ë‹¥)
        const planeGeometry = new THREE.PlaneGeometry(10000, 10000);
        const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xf9fafb, roughness: 1 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -1;
        plane.receiveShadow = true;
        scene.add(plane);

        const gridHelper = new THREE.GridHelper(5000, 500, 0xcbd5e1, 0xe2e8f0);
        scene.add(gridHelper);

        // Offset
        const offsetX = -window.innerWidth / 2;
        const offsetZ = -window.innerHeight / 2;

        // Build Scene Objects
        rooms.forEach(room => {
          const result = createRoomObjects(room, floorMaterial, ceilingMaterial, offsetX, offsetZ);
          if (result) {
            scene.add(result.floorMesh);
            scene.add(result.ceilingMesh);
            ceilingsRef.current.push(result.ceilingMesh);
          }
        });

        walls.forEach((wall, index) => {
          const result = createWallObjects(wall, index, openings, wallMaterial, offsetX, offsetZ);
          if (result.mesh) {
            scene.add(result.mesh);
          }
          if (result.doors.length > 0) {
            doorsRef.current.push(...result.doors);
          }
        });

        furniture.forEach(item => {
          const group = createFurnitureGroup(item, offsetX, offsetZ);
          if (group) {
            scene.add(group);
          }
        });

        // Controls Setup
        const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true;
        controlsRef.current = orbitControls;

        const fpvControls = new THREE.PointerLockControls(camera, renderer.domElement);
        fpvControls.addEventListener('lock', () => setIsLocked(true));
        fpvControls.addEventListener('unlock', () => setIsLocked(false));
        fpvControlsRef.current = fpvControls;

        // Initial Camera Position (Orbit)
        camera.position.set(500, 800, 800);
        camera.lookAt(0, 0, 0);

        let prevTime = performance.now();

        const animate = () => {
          requestRef.current = requestAnimationFrame(animate);

          const time = performance.now();
          const delta = (time - prevTime) / 1000;
          prevTime = time;

          if (fpvControls.isLocked) {
            const velocity = moveState.current.velocity;
            const direction = moveState.current.direction;

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            direction.z = Number(moveState.current.forward) - Number(moveState.current.backward);
            direction.x = Number(moveState.current.right) - Number(moveState.current.left);
            direction.normalize();

            if (moveState.current.forward || moveState.current.backward) velocity.z -= direction.z * 4000.0 * delta;
            if (moveState.current.left || moveState.current.right) velocity.x -= direction.x * 4000.0 * delta;

            // --- ì¶©ëŒ ì²˜ë¦¬ ê°œì„  (Move and Revert ë°©ì‹) ---

            // 1. Xì¶• ì´ë™ (ì¢Œìš°)
            const oldX = camera.position.x;
            const oldZ = camera.position.z;

            fpvControls.moveRight(-velocity.x * delta);

            if (checkPlayerCollision(camera.position.x, camera.position.z)) {
              camera.position.x = oldX;
              camera.position.z = oldZ;
              velocity.x = 0;
            }

            // 2. Zì¶• ì´ë™ (ì „í›„)
            const currX = camera.position.x;
            const currZ = camera.position.z;

            fpvControls.moveForward(-velocity.z * delta);

            if (checkPlayerCollision(camera.position.x, camera.position.z)) {
              camera.position.x = currX;
              camera.position.z = currZ;
              velocity.z = 0;
            }

            // 3. ë†’ì´ ê³ ì • (ë¹„í–‰/ë•…íŒŒê¸° ë°©ì§€)
            const h = gender === 'male' ? HEIGHT_MALE : HEIGHT_FEMALE;
            camera.position.y = h;

            // FPV ëª¨ë“œì¼ ë•Œ ì²œì¥ ë³´ì´ê¸°
            if (ceilingsRef.current.length > 0 && !ceilingsRef.current[0].visible) {
              ceilingsRef.current.forEach(c => c.visible = true);
            }
          } else {
            orbitControls.update();

            // Orbit ëª¨ë“œì¼ ë•Œ ì²œì¥ ìˆ¨ê¸°ê¸°
            if (ceilingsRef.current.length > 0 && ceilingsRef.current[0].visible) {
              ceilingsRef.current.forEach(c => c.visible = false);
            }
          }

          // ë¬¸ ì• ë‹ˆë©”ì´ì…˜ (ìë™ ì—´ë¦¼/ë‹«í˜)
          if (doorsRef.current.length > 0) {
            const playerPos = camera.position;
            doorsRef.current.forEach(door => {
              const worldPos = new THREE.Vector3();
              door.pivot.getWorldPosition(worldPos);

              // ë†’ì´ ì°¨ì´ëŠ” ë¬´ì‹œí•˜ê³  ìˆ˜í‰ ê±°ë¦¬ë§Œ ê³„ì‚°
              const dist = Math.sqrt(Math.pow(playerPos.x - worldPos.x, 2) + Math.pow(playerPos.z - worldPos.z, 2));

              // íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ì ìš© (ì—´ë¦¼: 150cm, ë‹«í˜: 250cm)
              const OPEN_DIST = 150;
              const CLOSE_DIST = 250;

              // ìƒíƒœ ì´ˆê¸°í™”
              if (door.targetAngle === undefined) door.targetAngle = 0;
              if (door.isOpen === undefined) door.isOpen = false;

              if (dist < OPEN_DIST) {
                if (!door.isOpen) {
                  // ì²˜ìŒ ì—´ë¦´ ë•Œ ë°©í–¥ ê²°ì •
                  const doorDir = new THREE.Vector3(0, 0, 1); // ë¬¸ì˜ ë¡œì»¬ ì •ë©´ (Zì¶•)
                  doorDir.applyQuaternion(door.pivot.getWorldQuaternion(new THREE.Quaternion()));

                  const toPlayer = new THREE.Vector3().subVectors(playerPos, worldPos).normalize();
                  const dot = doorDir.dot(toPlayer);

                  // í”Œë ˆì´ì–´ê°€ ì •ë©´(dot > 0)ì— ìˆìœ¼ë©´ ë’¤ë¡œ(-Zë°©í–¥, +90ë„) ì—´ë¦¼ (Push)
                  // í”Œë ˆì´ì–´ê°€ í›„ë©´(dot < 0)ì— ìˆìœ¼ë©´ ì•ìœ¼ë¡œ(+Zë°©í–¥, -90ë„) ì—´ë¦¼ (Push)
                  door.targetAngle = dot > 0 ? Math.PI / 2 : -Math.PI / 2;
                  door.isOpen = true;
                }
              } else if (dist > CLOSE_DIST) {
                door.targetAngle = 0;
                door.isOpen = false;
              }

              // ë¶€ë“œëŸ½ê²Œ íšŒì „ (Lerp ì†ë„ ì¡°ì ˆ: 0.1 -> 0.05)
              door.pivot.rotation.y = THREE.MathUtils.lerp(door.pivot.rotation.y, door.targetAngle, 0.05);
            });
          }

          renderer.render(scene, camera);
        };
        animate();

        // Key handlers for movement
        const onKeyDown = (event) => {
          switch (event.code) {
            case 'ArrowUp': case 'KeyW': moveState.current.forward = true; break;
            case 'ArrowLeft': case 'KeyA': moveState.current.left = true; break;
            case 'ArrowDown': case 'KeyS': moveState.current.backward = true; break;
            case 'ArrowRight': case 'KeyD': moveState.current.right = true; break;
          }
        };
        const onKeyUp = (event) => {
          switch (event.code) {
            case 'ArrowUp': case 'KeyW': moveState.current.forward = false; break;
            case 'ArrowLeft': case 'KeyA': moveState.current.left = false; break;
            case 'ArrowDown': case 'KeyS': moveState.current.backward = false; break;
            case 'ArrowRight': case 'KeyD': moveState.current.right = false; break;
          }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        return () => {
          if (mountRef.current) mountRef.current.innerHTML = '';
          renderer.dispose();
          cancelAnimationFrame(requestRef.current);
          document.removeEventListener('keydown', onKeyDown);
          document.removeEventListener('keyup', onKeyUp);
        };
      }, [walls, rooms, openings, furniture]);

      // Mode Switching Effect
      useEffect(() => {
        if (!cameraRef.current || !controlsRef.current) return;

        if (isFPV) {
          controlsRef.current.enabled = false;
          // Set initial FPV position (center of room or current position if reasonable)
          // Just reset to a safe height
          const h = gender === 'male' ? HEIGHT_MALE : HEIGHT_FEMALE;
          cameraRef.current.position.y = h;
          cameraRef.current.lookAt(cameraRef.current.position.x, h, cameraRef.current.position.z - 100);
        } else {
          controlsRef.current.enabled = true;
          if (fpvControlsRef.current) fpvControlsRef.current.unlock();
          // Reset to bird's eye view
          cameraRef.current.position.set(500, 800, 800);
          cameraRef.current.lookAt(0, 0, 0);
        }
      }, [isFPV, gender]);

      const toggleLock = () => {
        if (fpvControlsRef.current) {
          fpvControlsRef.current.lock();
        }
      };

      return (
        <div ref={mountRef} className="w-full h-full bg-gray-200 relative">
          <div className="absolute top-4 right-4 z-10 flex flex-col space-y-2">
            <button
              onClick={() => setIsFPV(!isFPV)}
              className={`px-4 py-2 rounded shadow font-bold ${isFPV ? 'bg-green-600 text-white' : 'bg-white text-gray-800'}`}
            >
              {isFPV ? 'ğŸ¦… 3D ì¡°ê°ë„ ëª¨ë“œ' : 'ğŸš¶ 1ì¸ì¹­ ê´€ëŒ ëª¨ë“œ'}
            </button>

            {isFPV && (
              <div className="bg-white p-4 rounded shadow-lg flex flex-col space-y-2">
                <p className="text-sm font-bold text-gray-600 mb-2">ì„¤ì •</p>
                <div className="flex space-x-2 bg-gray-100 p-1 rounded">
                  <button
                    onClick={() => setGender('male')}
                    className={`flex-1 py-1 rounded text-sm ${gender === 'male' ? 'bg-blue-500 text-white' : 'text-gray-600'}`}
                  >
                    ë‚¨ (180cm)
                  </button>
                  <button
                    onClick={() => setGender('female')}
                    className={`flex-1 py-1 rounded text-sm ${gender === 'female' ? 'bg-pink-500 text-white' : 'text-gray-600'}`}
                  >
                    ì—¬ (160cm)
                  </button>
                </div>

                {!isLocked && (
                  <button
                    onClick={toggleLock}
                    className="w-full py-3 bg-blue-600 text-white rounded font-bold hover:bg-blue-700 mt-2"
                  >
                    ê´€ëŒ ì‹œì‘ (í´ë¦­)
                  </button>
                )}

                <div className="text-xs text-gray-500 mt-2">
                  <p>W,A,S,D: ì´ë™</p>
                  <p>ë§ˆìš°ìŠ¤: ì‹œì„  ì´ë™</p>
                  <p>ESC: ì»¤ì„œ ì ê¸ˆ í•´ì œ</p>
                </div>
              </div>
            )}
          </div>
          {isFPV && !isLocked && (
            <div className="absolute inset-0 flex items-center justify-center bg-black/30 z-0 pointer-events-none">
              <div className="text-white text-2xl font-bold drop-shadow-md">
                ìš°ì¸¡ ìƒë‹¨ì˜ 'ê´€ëŒ ì‹œì‘'ì„ í´ë¦­í•˜ì„¸ìš”
              </div>
            </div>
          )}
        </div>
      );
    };

    // --- íˆ´ë°” ì»´í¬ë„ŒíŠ¸ ---
    const Toolbar = ({ tool, setTool, undo, redo, canUndo, canRedo, clearAll, mode, setMode, handleFileDownload, handleFileUpload }) => {
      const [openCategory, setOpenCategory] = useState(null);
      const toolbarRef = useRef(null);

      useEffect(() => {
        const handleClickOutside = (event) => {
            if (toolbarRef.current && !toolbarRef.current.contains(event.target)) {
                setOpenCategory(null);
            }
        };
        document.addEventListener("mousedown", handleClickOutside);
        return () => {
            document.removeEventListener("mousedown", handleClickOutside);
        };
      }, [toolbarRef]);

      const handleCategoryClick = (key, category) => {
        if (category.isDirect) {
            setTool(category.items[0].id);
            setOpenCategory(null);
        } else {
            setOpenCategory(openCategory === key ? null : key);
        }
      };

      const handleItemClick = (id) => {
          setTool(id);
          setOpenCategory(null);
      };

      return (
        <div className="bg-white/90 backdrop-blur-md border-b border-gray-200 p-4 flex justify-between items-center shadow-sm z-10 h-[80px]">
          <div className="flex items-center space-x-6">
            <h1 className="text-2xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-indigo-600 mr-4">
              Floor Planner <span className="text-xs font-medium text-gray-500">Pro</span>
            </h1>

            {/* ë©”ì¸ íˆ´ë°” */}
            <div ref={toolbarRef} className="flex bg-gray-100/50 p-1.5 rounded-xl space-x-1 border border-gray-200">
              {TOOLS.map(t => (
                <button
                  key={t.id}
                  onClick={() => setTool(tool === t.id ? 'select' : t.id)}
                  className={`px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 flex items-center space-x-2 ${tool === t.id
                    ? 'bg-white text-blue-600 shadow-md scale-105'
                    : 'text-gray-600 hover:bg-gray-200/80 hover:text-gray-900'
                    }`}
                >
                  <span>{t.icon}</span>
                  <span className="hidden lg:inline">{t.label}</span>
                </button>
              ))}
              <div className="w-px h-6 bg-gray-300 mx-2 self-center"></div>
              {/* ê°€êµ¬ íˆ´ë°” */}
              {Object.entries(FURNITURE_CATEGORIES).map(([key, category]) => (
                <div key={key} className="relative">
                    <button
                        onClick={() => handleCategoryClick(key, category)}
                        className={`p-2 rounded-lg text-xs font-medium transition-all duration-200 flex flex-col items-center justify-center w-10 h-10 ${
                            (openCategory === key || (category.items.some(item => item.id === tool)))
                                ? 'bg-white text-blue-600 shadow-md scale-105'
                                : 'text-gray-600 hover:bg-gray-200/80 hover:text-gray-900'
                        }`}
                        title={category.label}
                    >
                        <span className="text-lg leading-none">{category.icon}</span>
                    </button>
                    {openCategory === key && !category.isDirect && (
                        <div className="absolute top-full mt-2 w-48 bg-white rounded-xl shadow-lg border border-gray-100 z-20 p-2">
                            <div className="grid grid-cols-3 gap-2">
                                {category.items.map(item => (
                                    <button
                                        key={item.id}
                                        onClick={() => handleItemClick(item.id)}
                                        className={`p-2 rounded-lg text-xs font-medium transition-all duration-200 flex flex-col items-center justify-center w-full h-16 ${
                                            tool === item.id
                                                ? 'bg-blue-100 text-blue-700'
                                                : 'text-gray-600 hover:bg-gray-100'
                                        }`}
                                        title={item.label}
                                    >
                                        <span className="text-xl leading-none">{item.icon}</span>
                                        <span className="text-[10px] mt-1">{item.label}</span>
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
              ))}
            </div>

            {/* Undo/Redo */}
            <div className="flex bg-gray-100/50 p-1.5 rounded-xl space-x-1 border border-gray-200">
              <button
                onClick={undo}
                disabled={!canUndo}
                className={`p-2 rounded-lg transition-colors ${canUndo ? 'text-gray-700 hover:bg-white hover:shadow-sm' : 'text-gray-300 cursor-not-allowed'}`}
                title="ì‹¤í–‰ ì·¨ì†Œ (Ctrl+Z)"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path></svg>
              </button>
              <button
                onClick={redo}
                disabled={!canRedo}
                className={`p-2 rounded-lg transition-colors ${canRedo ? 'text-gray-700 hover:bg-white hover:shadow-sm' : 'text-gray-300 cursor-not-allowed'}`}
                title="ë‹¤ì‹œ ì‹¤í–‰ (Ctrl+Y)"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 10h-10a8 8 0 00-8 8v2M21 10l-6 6m6-6l-6-6"></path></svg>
              </button>
            </div>
          </div>

          <div className="flex items-center space-x-3">
            <input
              type="file"
              id="file-upload"
              className="hidden"
              accept=".json"
              onChange={handleFileUpload}
            />
            <div className="flex bg-gray-100/50 p-1 rounded-lg border border-gray-200">
              <button
                onClick={() => document.getElementById('file-upload').click()}
                className="px-3 py-1.5 rounded-md text-sm font-medium text-gray-600 hover:bg-white hover:shadow-sm transition-all"
                title="JSON íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°"
              >
                ğŸ“‚ ì—´ê¸°
              </button>
              <button
                onClick={handleFileDownload}
                className="px-3 py-1.5 rounded-md text-sm font-medium text-gray-600 hover:bg-white hover:shadow-sm transition-all"
                title="JSON íŒŒì¼ë¡œ ì €ì¥"
              >
                ğŸ’¾ ì €ì¥
              </button>
            </div>

            <div className="w-px h-8 bg-gray-200 mx-2"></div>

            <button onClick={clearAll} className="text-red-500 hover:bg-red-50 px-4 py-2 rounded-lg text-sm font-medium transition-colors">
              ì´ˆê¸°í™”
            </button>
            <button
              onClick={() => setMode(mode === '2D' ? '3D' : '2D')}
              className={`px-6 py-2.5 rounded-xl font-bold shadow-lg transition-all transform hover:-translate-y-0.5 active:translate-y-0 ${mode === '2D'
                ? 'bg-gradient-to-r from-blue-600 to-indigo-600 text-white hover:shadow-blue-500/30'
                : 'bg-white text-gray-800 border border-gray-200 hover:bg-gray-50'
                }`}
            >
              {mode === '2D' ? '3Dë¡œ ë³´ê¸° âœ¨' : '2D í¸ì§‘ê¸°ë¡œ ëŒì•„ê°€ê¸°'}
            </button>
          </div>
        </div>
      );
    };

    const HelpButton = () => {
      return (
        <div className="absolute bottom-6 right-6 z-50 group">
          <button className="w-12 h-12 bg-white rounded-full shadow-lg flex items-center justify-center text-gray-600 hover:text-blue-600 hover:scale-110 transition-all border border-gray-200">
            <span className="text-xl font-bold">?</span>
          </button>
          <div className="absolute bottom-16 right-0 w-64 bg-white/90 backdrop-blur-md p-4 rounded-2xl shadow-xl border border-white/50 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none group-hover:pointer-events-auto transform translate-y-2 group-hover:translate-y-0 duration-200">
            <h4 className="font-bold text-gray-800 mb-3 text-sm">ë‹¨ì¶•í‚¤ ì•ˆë‚´</h4>
            <div className="space-y-2 text-xs text-gray-600">
              <div className="flex justify-between"><span>ì‹¤í–‰ ì·¨ì†Œ</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Ctrl + Z</kbd></div>
              <div className="flex justify-between"><span>ë‹¤ì‹œ ì‹¤í–‰</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Ctrl + Y</kbd></div>
              <div className="flex justify-between"><span>íšŒì „ (ê°€êµ¬)</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">R</kbd></div>
              <div className="flex justify-between"><span>ì‚­ì œ</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Del</kbd></div>
              <div className="flex justify-between"><span>ì·¨ì†Œ</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Esc</kbd></div>
              <div className="border-t border-gray-200 my-2 pt-2"></div>
              <div className="flex justify-between"><span>3D ì´ë™</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">W A S D</kbd></div>
              <div className="flex justify-between"><span>ì‹œì„  ì´ë™</span> <span className="text-gray-500">ë§ˆìš°ìŠ¤</span></div>
            </div>
          </div>
        </div>
      );
    };

    // --- ë©”ì¸ ì•± ì»´í¬ë„ŒíŠ¸ ---
    const App = () => {
      const [mode, setMode] = useState('2D');
      const [tool, setTool] = useState('select'); // 'select', 'wall', 'room', 'door', 'window', 'bed_single', 'desk', etc.

      // Undo/Redoë¥¼ ìœ„í•œ í†µí•© ìƒíƒœ ê´€ë¦¬
      const { state, pushState, undo, redo, reset, canUndo, canRedo } = useHistory({
        walls: [],
        rooms: [],
        openings: [],
        furniture: []
      });

      const { walls, rooms, openings, furniture } = state;

      // ì„ì‹œ ê·¸ë¦¬ê¸° ìƒíƒœ (íˆìŠ¤í† ë¦¬ì— ì €ì¥ ì•ˆ í•¨)
      const [currentWall, setCurrentWall] = useState(null);
      const [currentRoom, setCurrentRoom] = useState([]);
      const [previewOpening, setPreviewOpening] = useState(null);
      const [previewFurniture, setPreviewFurniture] = useState(null); // { type, x, y, rotation }
      const [selectedFurnitureId, setSelectedFurnitureId] = useState(null);
      const [isDraggingFurniture, setIsDraggingFurniture] = useState(false);

      // ë·°í¬íŠ¸ ìƒíƒœ (ì¤Œ & íŒ¬)
      const [scale, setScale] = useState(1);
      const [pan, setPan] = useState({ x: 0, y: 0 });
      const [isPanning, setIsPanning] = useState(false);
      const [lastMousePos, setLastMousePos] = useState({ x: 0, y: 0 });

      // ìŠ¤ë§ˆíŠ¸ ê°€ì´ë“œ ìƒíƒœ
      const [guides, setGuides] = useState([]); // [{ type: 'x'|'y', pos: number, start: number, end: number }]

      const canvasRef = useRef(null);

      const allFurnitureTools = useMemo(() => {
        return Object.values(FURNITURE_CATEGORIES).flatMap(category => category.items);
      }, []);

      // ë‹¨ì¶•í‚¤ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
      useEffect(() => {
        const handleKeyDown = (e) => {
          // Ctrl+Z (Undo), Ctrl+Shift+Z or Ctrl+Y (Redo)
          if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
            if (e.shiftKey) {
              e.preventDefault();
              if (canRedo) redo();
            } else {
              e.preventDefault();
              if (canUndo) undo();
            }
          } else if ((e.metaKey || e.ctrlKey) && e.key === 'y') {
            e.preventDefault();
            if (canRedo) redo();
          } else if (e.code === 'KeyR') {
            // ê°€êµ¬ íšŒì „
            if (previewFurniture) {
              setPreviewFurniture(prev => ({
                ...prev,
                rotation: (prev.rotation + Math.PI / 2) % (Math.PI * 2)
              }));
            } else if (selectedFurnitureId) {
              // ì„ íƒëœ ê°€êµ¬ íšŒì „
              pushState({
                ...state,
                furniture: furniture.map(f =>
                  f.id === selectedFurnitureId
                    ? { ...f, rotation: (f.rotation + Math.PI / 2) % (Math.PI * 2) }
                    : f
                )
              });
            }
          } else if (e.key === 'Delete' || e.key === 'Backspace') {
            if (selectedFurnitureId) {
              pushState({
                ...state,
                furniture: furniture.filter(f => f.id !== selectedFurnitureId)
              });
              setSelectedFurnitureId(null);
            }
          } else if (e.key === 'Escape') {
            setTool('select');
            setSelectedFurnitureId(null);
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [undo, redo, canUndo, canRedo, previewFurniture, selectedFurnitureId, furniture, state, pushState]);

      // íˆ´ ë³€ê²½ ì‹œ ì„ì‹œ ìƒíƒœ ì´ˆê¸°í™”
      useEffect(() => {
        setCurrentWall(null);
        setCurrentRoom([]);
        setPreviewOpening(null);
        setPreviewFurniture(null);
        setSelectedFurnitureId(null);
      }, [tool]);

      // --- ë°ì´í„° ì €ì¥/ë¡œë“œ (LocalStorage & File) ---

      // 1. ìë™ ì €ì¥ (Auto Save)
      useEffect(() => {
        const data = { walls, rooms, openings, furniture };
        localStorage.setItem('floorPlanData', JSON.stringify(data));
      }, [walls, rooms, openings, furniture]);

      // 2. ì´ˆê¸° ë¡œë“œ (Auto Load)
      useEffect(() => {
        const savedData = localStorage.getItem('floorPlanData');
        if (savedData) {
          try {
            const parsed = JSON.parse(savedData);
            // ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬ (ê°„ë‹¨íˆ)
            if (parsed.walls && parsed.rooms) {
              reset(parsed);
            }
          } catch (e) {
            console.error("Failed to load saved data", e);
          }
        }
      }, []); // Mount ì‹œ 1íšŒ ì‹¤í–‰

      // 3. íŒŒì¼ ë‹¤ìš´ë¡œë“œ í•¸ë“¤ëŸ¬
      const handleFileDownload = () => {
        const data = { walls, rooms, openings, furniture, timestamp: Date.now() };
        downloadFloorPlan(data);
      };

      // 4. íŒŒì¼ ì—…ë¡œë“œ í•¸ë“¤ëŸ¬
      const handleFileUpload = (e) => {
        const file = e.target.files[0];
        uploadFloorPlan(
          file,
          (parsed) => {
            reset({
              walls: parsed.walls || [],
              rooms: parsed.rooms || [],
              openings: parsed.openings || [],
              furniture: parsed.furniture || []
            });
            alert("íŒŒì¼ì„ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.");
          },
          (errorMessage) => {
            alert(errorMessage);
          }
        );
        // ê°™ì€ íŒŒì¼ì„ ë‹¤ì‹œ ì„ íƒí•  ìˆ˜ ìˆë„ë¡ value ì´ˆê¸°í™”
        e.target.value = '';
      };

      // í™”ë©´ ì¢Œí‘œ -> ì›”ë“œ ì¢Œí‘œ ë³€í™˜
      const screenToWorld = (sx, sy) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const x = (sx - rect.left - pan.x) / scale;
        const y = (sy - rect.top - pan.y) / scale;
        return { x, y };
      };

      // ìŠ¤ë§ˆíŠ¸ ìŠ¤ëƒ… í•¨ìˆ˜ (Imported Wrapper)
      const getSnappedPositionWrapper = (x, y) => {
        return getSnappedPosition(x, y, walls, rooms, scale);
      };

      // ìº”ë²„ìŠ¤ ë Œë”ë§
      useEffect(() => {
        if (mode !== '2D') return;

        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight - 80;

        // ë°°ê²½
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();

        // ì¤Œ & íŒ¬ ì ìš©
        ctx.translate(pan.x, pan.y);
        ctx.scale(scale, scale);

        // ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸°
        drawGrid(ctx, canvas, scale, pan);

        // 1. ë°© ê·¸ë¦¬ê¸°
        rooms.forEach(room => drawRoom(ctx, room.points, false, scale));
        if (currentRoom.length > 0) {
          drawRoom(ctx, currentRoom, true, scale);
          ctx.beginPath();
          ctx.strokeStyle = "blue";
          ctx.setLineDash([5 / scale, 5 / scale]);
          ctx.lineWidth = 2 / scale;
          ctx.moveTo(currentRoom[currentRoom.length - 1].x, currentRoom[currentRoom.length - 1].y);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // 2. ë²½ ê·¸ë¦¬ê¸°
        walls.forEach(wall => drawWall(ctx, wall, 'black', scale));
        if (currentWall) drawWall(ctx, currentWall, 'red', scale, true);

        // 3. ì˜¤í”„ë‹ ê·¸ë¦¬ê¸°
        openings.forEach(op => drawOpening(ctx, op, walls, scale));
        if (previewOpening) drawOpening(ctx, previewOpening, walls, scale, true);

        // 4. ê°€êµ¬ ê·¸ë¦¬ê¸°
        furniture.forEach(item => {
          // ë“œë˜ê·¸ ì¤‘ì¸ ê°€êµ¬ëŠ” ê·¸ë¦¬ì§€ ì•ŠìŒ (previewFurnitureë¡œ ê·¸ë ¤ì§)
          if (isDraggingFurniture && item.id === selectedFurnitureId) return;
          drawFurniture(ctx, item, scale, selectedFurnitureId);
        });
        if (previewFurniture) drawFurniture(ctx, previewFurniture, scale, selectedFurnitureId, true);

        // 5. ìŠ¤ë§ˆíŠ¸ ê°€ì´ë“œ ê·¸ë¦¬ê¸°
        if (guides.length > 0) {
          ctx.beginPath();
          ctx.strokeStyle = "#ec4899"; // Pink-500
          ctx.lineWidth = 1 / scale;
          ctx.setLineDash([4 / scale, 4 / scale]);
          guides.forEach(g => {
            if (g.type === 'x') {
              ctx.moveTo(g.pos, -10000); // í™”ë©´ ì „ì²´ë¥¼ ê°€ë¡œì§€ë¥´ë„ë¡
              ctx.lineTo(g.pos, 10000);
            } else {
              ctx.moveTo(-10000, g.pos);
              ctx.lineTo(10000, g.pos);
            }
          });
          ctx.stroke();
          ctx.setLineDash([]);
        }

        ctx.restore();

      }, [walls, rooms, openings, furniture, currentWall, currentRoom, previewOpening, previewFurniture, mode, scale, pan, guides]);



      const handleWheel = (e) => {
        if (mode !== '2D') return;
        e.preventDefault();

        const zoomSensitivity = 0.001;
        const delta = -e.deltaY * zoomSensitivity;
        const newScale = Math.min(Math.max(0.1, scale + delta), 5);

        const rect = canvasRef.current.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const worldX = (mouseX - pan.x) / scale;
        const worldY = (mouseY - pan.y) / scale;

        const newPanX = mouseX - worldX * newScale;
        const newPanY = mouseY - worldY * newScale;

        setScale(newScale);
        setPan({ x: newPanX, y: newPanY });
      };

      const handleMouseDown = (e) => {
        if (mode !== '2D') return;

        if (e.button === 1 || e.button === 2 || (e.button === 0 && e.shiftKey)) {
          setIsPanning(true);
          setLastMousePos({ x: e.clientX, y: e.clientY });
          return;
        }

        const worldPos = screenToWorld(e.clientX, e.clientY);
        // ë§ˆìš°ìŠ¤ ë‹¤ìš´ ì‹œì—ë„ ìŠ¤ëƒ… ì ìš© (ì‹œì‘ì  ìŠ¤ëƒ…)
        const snapped = getSnappedPositionWrapper(worldPos.x, worldPos.y);
        const x = snapped.x;
        const y = snapped.y;

        if (tool === 'select') {
          // ê°€êµ¬ ì„ íƒ ë¡œì§ (MouseDownì—ì„œ ì²˜ë¦¬)
          let clickedFurnitureId = null;
          for (let i = furniture.length - 1; i >= 0; i--) {
            const item = furniture[i];
            const template = FURNITURE_TEMPLATES[item.type];
            if (!template) continue;

            const dx = worldPos.x - item.x;
            const dy = worldPos.y - item.y;

            // ì ì„ ê°€êµ¬ì˜ ë¡œì»¬ ì¢Œí‘œê³„ë¡œ ë³€í™˜ (íšŒì „ ê³ ë ¤)
            const cos = Math.cos(-item.rotation);
            const sin = Math.sin(-item.rotation);
            const localX = dx * cos - dy * sin;
            const localY = dx * sin + dy * cos;

            if (Math.abs(localX) <= template.width / 2 && Math.abs(localY) <= template.depth / 2) {
              clickedFurnitureId = item.id;
              break;
            }
          }

          if (clickedFurnitureId) {
            setSelectedFurnitureId(clickedFurnitureId);
            setIsDraggingFurniture(true);
            // ë“œë˜ê·¸ ì‹œì‘ ì‹œ ë¯¸ë¦¬ë³´ê¸° ì„¤ì • (ì„ íƒì )
            const item = furniture.find(f => f.id === clickedFurnitureId);
            setPreviewFurniture({ ...item });
          } else {
            setSelectedFurnitureId(null);
          }
        } else if (tool === 'wall') {
          setCurrentWall({ start: { x, y }, end: { x, y } });
        } else if (tool === 'room') {
          setCurrentRoom([{ x, y }, { x, y }, { x, y }, { x, y }]);
        } else if (tool === 'door' || tool === 'window' || tool === 'balcony') {
          if (previewOpening) {
            pushState({
              ...state,
              openings: [...openings, previewOpening]
            });
            setPreviewOpening(null);
          }
        } else if (FURNITURE_TEMPLATES[tool]) {
          if (previewFurniture) {
            pushState({
              ...state,
              furniture: [...furniture, { ...previewFurniture, id: Date.now() }]
            });
          }
        }
      };

      const handleMouseMove = (e) => {
        if (mode !== '2D') return;

        if (isPanning) {
          const dx = e.clientX - lastMousePos.x;
          const dy = e.clientY - lastMousePos.y;
          setPan(prev => ({ x: prev.x + dx, y: prev.y + dy }));
          setLastMousePos({ x: e.clientX, y: e.clientY });
          return;
        }

        const worldPos = screenToWorld(e.clientX, e.clientY);

        // ìŠ¤ë§ˆíŠ¸ ìŠ¤ëƒ… ì ìš©
        const snapped = getSnappedPositionWrapper(worldPos.x, worldPos.y);
        const x = snapped.x;
        const y = snapped.y;

        // ê°€ì´ë“œë¼ì¸ ì—…ë°ì´íŠ¸ (ë²½ì´ë‚˜ ë°© ê·¸ë¦¬ê¸° ë„êµ¬ì¼ ë•Œë§Œ)
        if (tool === 'wall' || tool === 'room') {
          setGuides(snapped.guides);
        } else {
          setGuides([]);
        }

        if (tool === 'wall' && currentWall) {
          let targetX = x;
          let targetY = y;

          // Shift í‚¤ë¥¼ ëˆ„ë¥´ë©´ ìˆ˜ì§/ìˆ˜í‰ ê³ ì •
          if (e.shiftKey) {
            const dx = Math.abs(x - currentWall.start.x);
            const dy = Math.abs(y - currentWall.start.y);
            if (dx > dy) {
              targetY = currentWall.start.y;
            } else {
              targetX = currentWall.start.x;
            }
          }
          setCurrentWall(prev => ({ ...prev, end: { x: targetX, y: targetY } }));
        } else if (tool === 'room' && currentRoom.length > 0) {
          const start = currentRoom[0];
          const end = { x, y };
          const newPoints = [
            start,
            { x: end.x, y: start.y },
            end,
            { x: start.x, y: end.y }
          ];
          setCurrentRoom(newPoints);
        } else if (tool === 'door' || tool === 'window' || tool === 'balcony') {
          let minDist = 20 / scale;
          let nearest = null;

          walls.forEach((wall, idx) => {
            const proj = projectPointOnLine({ x: worldPos.x, y: worldPos.y }, wall.start, wall.end);
            const d = distance({ x: worldPos.x, y: worldPos.y }, proj);
            if (d < minDist) {
              minDist = d;
              nearest = { wall, idx, t: proj.t };
            }
          });

          if (nearest) {
            setPreviewOpening({
              type: tool,
              wallIndex: nearest.idx,
              t: nearest.t,
              width: tool === 'door' ? DOOR_WIDTH : (tool === 'balcony' ? BALCONY_WIDTH : WINDOW_WIDTH),
              height: tool === 'door' ? DOOR_HEIGHT : (tool === 'balcony' ? BALCONY_HEIGHT : WINDOW_HEIGHT)
            });
          } else {
            setPreviewOpening(null);
          }
        } else if (FURNITURE_TEMPLATES[tool]) {
          setPreviewFurniture(prev => ({
            type: tool,
            x,
            y,
            rotation: prev ? prev.rotation : 0
          }));
        } else if (tool === 'select' && isDraggingFurniture && selectedFurnitureId) {
          // ê°€êµ¬ ì´ë™ ì¤‘ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
          setPreviewFurniture({
            ...furniture.find(f => f.id === selectedFurnitureId),
            x, y
          });
        }
      };

      const handleMouseUp = () => {
        if (mode !== '2D') return;

        if (isPanning) {
          setIsPanning(false);
          return;
        }

        if (tool === 'wall' && currentWall) {
          if (currentWall.start.x !== currentWall.end.x || currentWall.start.y !== currentWall.end.y) {
            pushState({
              ...state,
              walls: [...walls, currentWall]
            });
          }
          setCurrentWall(null);
        } else if (tool === 'room' && currentRoom.length > 0) {
          if (currentRoom[0].x !== currentRoom[2].x || currentRoom[0].y !== currentRoom[2].y) {
            pushState({
              ...state,
              rooms: [...rooms, { points: currentRoom }]
            });
          }
          setCurrentRoom([]);
        } else if (tool === 'select' && isDraggingFurniture && selectedFurnitureId && previewFurniture) {
          // ë“œë˜ê·¸ ì¢…ë£Œ: ë³€ê²½ëœ ìœ„ì¹˜ ë° íšŒì „ ì €ì¥
          const updatedFurniture = furniture.map(f =>
            f.id === selectedFurnitureId ? { ...f, x: previewFurniture.x, y: previewFurniture.y, rotation: previewFurniture.rotation } : f
          );
          pushState({
            ...state,
            furniture: updatedFurniture
          });
          setIsDraggingFurniture(false);
          setPreviewFurniture(null);
        }
      };

      const handleDoubleClick = () => { };

      const clearAll = () => {
        if (confirm("ì •ë§ ëª¨ë‘ ì§€ìš°ì‹œê² ìŠµë‹ˆê¹Œ?")) {
          reset({ walls: [], rooms: [], openings: [], furniture: [] });
          setCurrentWall(null);
          setCurrentRoom([]);
          setPreviewOpening(null);
          setPreviewFurniture(null);
          setScale(1);
          setPan({ x: 0, y: 0 });
        }
      };

      return (
        <div className="flex flex-col h-screen relative" onContextMenu={(e) => e.preventDefault()}>
          <Toolbar
            tool={tool}
            setTool={setTool}
            undo={undo}
            redo={redo}
            canUndo={canUndo}
            canRedo={canRedo}
            clearAll={clearAll}
            mode={mode}
            setMode={setMode}
            handleFileDownload={handleFileDownload}
            handleFileUpload={handleFileUpload}
          />

          <div className="flex-1 relative overflow-hidden">
            {mode === '2D' ? (
              <div className="w-full h-full bg-white cursor-crosshair">
                <canvas
                  ref={canvasRef}
                  onMouseDown={handleMouseDown}
                  onMouseMove={handleMouseMove}
                  onMouseUp={handleMouseUp}
                  onDoubleClick={handleDoubleClick}
                  onWheel={handleWheel}
                  className="block"
                />
                <div className="absolute top-6 left-6 bg-white/90 backdrop-blur-md p-4 rounded-2xl shadow-lg border border-white/50 max-w-xs transition-all duration-300 pointer-events-none z-20">
                  <div className="flex items-center space-x-2 mb-2">
                    <span className="text-2xl">{TOOLS.find(t => t.id === tool)?.icon || allFurnitureTools.find(t => t.id === tool)?.icon || 'ğŸ‘†'}</span>
                    <h3 className="font-bold text-gray-800 text-sm">
                      {TOOLS.find(t => t.id === tool)?.label || allFurnitureTools.find(t => t.id === tool)?.label || 'ì„ íƒ ëª¨ë“œ'}
                    </h3>
                  </div>
                  <p className="text-xs text-gray-600 leading-relaxed">
                    {tool === 'select' && "ê°ì²´ë¥¼ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ê±°ë‚˜ ë“œë˜ê·¸í•˜ì—¬ ì´ë™í•˜ì„¸ìš”."}
                    {tool === 'wall' && "ë§ˆìš°ìŠ¤ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ë²½ì„ ê·¸ë¦¬ì„¸ìš”. Shiftë¥¼ ëˆ„ë¥´ë©´ ìˆ˜ì§/ìˆ˜í‰ìœ¼ë¡œ ê³ ì •ë©ë‹ˆë‹¤."}
                    {tool === 'room' && "ë“œë˜ê·¸í•˜ì—¬ ì‚¬ê°í˜• ë°©ì„ ë§Œë“œì„¸ìš”."}
                    {(tool === 'door' || tool === 'window' || tool === 'balcony') && "ë²½ ìœ„ì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë ¤ ë°°ì¹˜í•˜ì„¸ìš”."}
                    {FURNITURE_TEMPLATES[tool] && "ì›í•˜ëŠ” ìœ„ì¹˜ì— í´ë¦­í•˜ì—¬ ë°°ì¹˜í•˜ì„¸ìš”."}
                  </p>
                  <div className="mt-3 pt-3 border-t border-gray-100 grid grid-cols-2 gap-2 text-[10px] text-gray-500">
                    <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">ğŸ–±ï¸</span> ì´ë™/ì¤Œ</div>
                    {FURNITURE_TEMPLATES[tool] && <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">R</span> íšŒì „</div>}
                    <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">âŒ«</span> ì‚­ì œ</div>
                    <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">Esc</span> ì·¨ì†Œ</div>
                  </div>
                </div>
              </div>
            ) : (
              <Viewer3D walls={walls} rooms={rooms} openings={openings} furniture={furniture} />
            )}
            <HelpButton />
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
    // v1.1
  </script>
</body>

</html>