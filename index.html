<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Simple Floor Planner</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #f3f4f6;
      overscroll-behavior: none;
      -webkit-overflow-scrolling: touch;
    }

    canvas {
      display: block;
    }

    .canvas-container {
      cursor: crosshair;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.05);
      touch-action: none;
    }

    /* Toast notification */
    .toast {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      color: white;
      padding: 12px 24px;
      border-radius: 12px;
      font-size: 14px;
      z-index: 9999;
      pointer-events: none;
      animation: toastIn 0.3s ease, toastOut 0.3s ease 2.2s forwards;
    }
    @keyframes toastIn { from { opacity:0; transform: translateX(-50%) translateY(20px); } to { opacity:1; transform: translateX(-50%) translateY(0); } }
    @keyframes toastOut { from { opacity:1; } to { opacity:0; } }

    /* Virtual Joystick */
    .joystick-container {
      position: absolute;
      bottom: 32px;
      left: 32px;
      width: 120px;
      height: 120px;
      z-index: 40;
      touch-action: none;
    }
    .joystick-base {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
      border: 2px solid rgba(255,255,255,0.5);
      position: relative;
    }
    .joystick-knob {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: rgba(255,255,255,0.7);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: none;
    }

    /* Mobile bottom sheet */
    .bottom-sheet {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      border-top-left-radius: 20px;
      border-top-right-radius: 20px;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.15);
      z-index: 50;
      max-height: 60vh;
      overflow-y: auto;
      transform: translateY(0);
      transition: transform 0.3s ease;
    }
    .bottom-sheet-handle {
      width: 40px;
      height: 4px;
      background: #d1d5db;
      border-radius: 2px;
      margin: 8px auto;
    }

    /* FAB */
    .fab {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      font-size: 20px;
      border: none;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    /* Scrollable toolbar on mobile */
    @media (max-width: 767px) {
      .toolbar-scroll {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
      }
      .toolbar-scroll::-webkit-scrollbar {
        display: none;
      }
    }

    /* Custom modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .modal-content {
      background: white;
      border-radius: 16px;
      padding: 24px;
      max-width: 320px;
      width: 90%;
      text-align: center;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import {
      GRID_SIZE, VISUAL_GRID_SIZE, WALL_THICKNESS, WALL_HEIGHT,
      DOOR_WIDTH, DOOR_HEIGHT, WINDOW_WIDTH, WINDOW_HEIGHT, WINDOW_SILL,
      BALCONY_WIDTH, BALCONY_HEIGHT, HEIGHT_MALE, HEIGHT_FEMALE,
      TOOLS, FURNITURE_CATEGORIES, FURNITURE_TEMPLATES, CUSTOM_FURNITURE_TYPES, getEffectiveDimensions,
      WALL_MATERIALS, FLOOR_MATERIALS
    } from './src/config/constants.js';

    import { snapToGrid, distance, projectPointOnLine, isPointInPolygon } from './src/utils/geometry.js';
    import { getSnappedPosition } from './src/utils/snap.js';
    import { checkCollision } from './src/utils/collision.js';
    import { createFloorTexture, createWallTexture, createCeilingTexture } from './src/rendering/textures.js';
    import { drawRoom, drawWall, drawOpening, drawFurniture, drawGrid } from './src/rendering/canvas2d.js';
    import { createRoomObjects, createWallObjects } from './src/rendering/sceneBuilder.js';
    import { createFurnitureGroup } from './src/rendering/furnitureBuilder.js';
    import { downloadFloorPlan, uploadFloorPlan } from './src/utils/fileHandler.js';
    import { findClosedRegion } from './src/utils/roomDetection.js';
    import { useHistory } from './src/hooks/useHistory.js';
    import { useIsMobile } from './src/hooks/useIsMobile.js';
    import { useTouchHandlers } from './src/hooks/useTouchHandlers.js';

    const { useState, useEffect, useRef, useMemo, useCallback } = React;
    const { OrbitControls, PointerLockControls } = THREE;

    // 설정 값
    // 유틸리티 및 상수는 import 됨

    // --- Toast 알림 헬퍼 ---
    const showToast = (message) => {
      const existing = document.querySelector('.toast');
      if (existing) existing.remove();
      const el = document.createElement('div');
      el.className = 'toast';
      el.textContent = message;
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 2500);
    };

    // --- 확인 모달 컴포넌트 ---
    const ConfirmModal = ({ message, onConfirm, onCancel }) => {
      return (
        <div className="modal-overlay" onClick={onCancel}>
          <div className="modal-content" onClick={e => e.stopPropagation()}>
            <p className="text-gray-800 font-medium mb-6">{message}</p>
            <div className="flex space-x-3 justify-center">
              <button
                onClick={onCancel}
                className="px-6 py-2 rounded-lg bg-gray-200 text-gray-700 font-medium active:bg-gray-300"
              >
                취소
              </button>
              <button
                onClick={onConfirm}
                className="px-6 py-2 rounded-lg bg-red-500 text-white font-medium active:bg-red-600"
              >
                확인
              </button>
            </div>
          </div>
        </div>
      );
    };

    const CustomFurnitureModal = ({ onConfirm, onCancel }) => {
      const [selectedKind, setSelectedKind] = React.useState(null);
      const [dims, setDims] = React.useState({ width: '', depth: '', height: '' });
      const [error, setError] = React.useState('');

      const handleKindSelect = (kind) => {
        setSelectedKind(kind);
        setDims({ width: String(kind.defaultWidth), depth: String(kind.defaultDepth), height: String(kind.defaultHeight) });
        setError('');
      };

      const handleConfirm = () => {
        if (!selectedKind) { setError('가구 종류를 선택해주세요.'); return; }
        const w = parseInt(dims.width, 10), d = parseInt(dims.depth, 10), h = parseInt(dims.height, 10);
        if (isNaN(w) || isNaN(d) || isNaN(h)) { setError('치수를 올바르게 입력해주세요.'); return; }
        if (w < 10 || d < 10 || h < 5) { setError('최소 크기: 가로/세로 10cm, 높이 5cm'); return; }
        if (w > 500 || d > 500 || h > 300) { setError('최대 크기: 가로/세로 500cm, 높이 300cm'); return; }
        onConfirm({
          type: selectedKind.baseType,
          customWidth: w,
          customDepth: d,
          customHeight: h,
          customLabel: selectedKind.label,
        });
      };

      return (
        <div className="modal-overlay" onClick={onCancel}>
          <div className="modal-content" onClick={e => e.stopPropagation()} style={{ maxWidth: '420px', textAlign: 'left' }}>
            <h3 style={{ fontSize: '18px', fontWeight: 'bold', color: '#1f2937', marginBottom: '16px' }}>가구 만들기</h3>

            <div style={{ marginBottom: '16px' }}>
              <div style={{ fontSize: '13px', fontWeight: '600', color: '#374151', marginBottom: '10px' }}>종류 선택</div>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '8px' }}>
                {CUSTOM_FURNITURE_TYPES.map(kind => (
                  <button key={kind.id} onClick={() => handleKindSelect(kind)}
                    style={{
                      display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
                      padding: '10px 4px', borderRadius: '10px', border: 'none', cursor: 'pointer',
                      background: selectedKind?.id === kind.id ? '#3b82f6' : '#f3f4f6',
                      color: selectedKind?.id === kind.id ? 'white' : '#4b5563',
                      transition: 'all 0.15s',
                    }}>
                    <span style={{ fontSize: '22px', lineHeight: 1 }}>{kind.icon}</span>
                    <span style={{ fontSize: '11px', fontWeight: '500', marginTop: '4px' }}>{kind.label}</span>
                  </button>
                ))}
              </div>
            </div>

            {selectedKind && (
              <div style={{ marginBottom: '16px' }}>
                <div style={{ fontSize: '13px', fontWeight: '600', color: '#374151', marginBottom: '8px' }}>치수 입력 (cm)</div>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '12px' }}>
                  {[
                    { key: 'width', label: '가로(W)' },
                    { key: 'depth', label: '세로(D)' },
                    { key: 'height', label: '높이(H)' },
                  ].map(({ key, label }) => (
                    <div key={key}>
                      <div style={{ fontSize: '11px', color: '#9ca3af', marginBottom: '4px' }}>{label}</div>
                      <input type="number" value={dims[key]}
                        onChange={e => setDims(prev => ({ ...prev, [key]: e.target.value }))}
                        style={{
                          width: '100%', padding: '8px 12px', border: '1px solid #d1d5db', borderRadius: '8px',
                          fontSize: '14px', outline: 'none', boxSizing: 'border-box',
                        }}
                        onFocus={e => e.target.style.borderColor = '#3b82f6'}
                        onBlur={e => e.target.style.borderColor = '#d1d5db'}
                        min="1" max="500" placeholder="cm"
                      />
                    </div>
                  ))}
                </div>
              </div>
            )}

            {error && <div style={{ fontSize: '12px', color: '#ef4444', marginBottom: '12px' }}>{error}</div>}

            <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '8px' }}>
              <button onClick={onCancel}
                className="px-6 py-2 rounded-lg bg-gray-200 text-gray-700 font-medium active:bg-gray-300">취소</button>
              <button onClick={handleConfirm}
                className="px-6 py-2 rounded-lg bg-blue-500 text-white font-medium active:bg-blue-600"
                style={{ opacity: selectedKind ? 1 : 0.5 }}>배치</button>
            </div>
          </div>
        </div>
      );
    };

    // --- 가상 조이스틱 컴포넌트 ---
    const VirtualJoystick = ({ onMove, onEnd }) => {
      const baseRef = useRef(null);
      const knobRef = useRef(null);
      const stateRef = useRef({ active: false, startX: 0, startY: 0 });

      const handleStart = (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = baseRef.current.getBoundingClientRect();
        stateRef.current = {
          active: true,
          startX: rect.left + rect.width / 2,
          startY: rect.top + rect.height / 2
        };
      };

      const handleMove = (e) => {
        if (!stateRef.current.active) return;
        e.preventDefault();
        const touch = e.touches[0];
        const s = stateRef.current;
        let dx = touch.clientX - s.startX;
        let dy = touch.clientY - s.startY;
        const maxDist = 40;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > maxDist) {
          dx = (dx / dist) * maxDist;
          dy = (dy / dist) * maxDist;
        }
        if (knobRef.current) {
          knobRef.current.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        }
        onMove(dx / maxDist, dy / maxDist);
      };

      const handleEnd = () => {
        stateRef.current.active = false;
        if (knobRef.current) {
          knobRef.current.style.transform = 'translate(-50%, -50%)';
        }
        onEnd();
      };

      useEffect(() => {
        const el = baseRef.current;
        if (!el) return;
        el.addEventListener('touchstart', handleStart, { passive: false });
        el.addEventListener('touchmove', handleMove, { passive: false });
        el.addEventListener('touchend', handleEnd);
        return () => {
          el.removeEventListener('touchstart', handleStart);
          el.removeEventListener('touchmove', handleMove);
          el.removeEventListener('touchend', handleEnd);
        };
      }, []);

      return (
        <div
          ref={baseRef}
          className="joystick-container"
        >
          <div className="joystick-base">
            <div ref={knobRef} className="joystick-knob"></div>
          </div>
        </div>
      );
    };

    // --- 모바일 FAB 버튼 컴포넌트 ---
    const MobileFABs = ({ tool, selectedFurnitureId, previewFurniture, onUndo, onRedo, canUndo, canRedo, onRotate, onDelete, onCancel, onToggleStraight, straightMode, currentWall }) => {
      return (
        <div className="absolute bottom-6 right-6 z-40 flex flex-col items-end space-y-3">
          {/* 직선 모드 토글 (벽 그리기 중) */}
          {tool === 'wall' && (
            <button
              onClick={onToggleStraight}
              className={`fab ${straightMode ? 'bg-blue-500 text-white' : 'bg-white text-gray-700'}`}
              title="직선 모드"
            >
              {straightMode ? '┃' : '∠'}
            </button>
          )}

          {/* 회전 (가구 선택 시) */}
          {(selectedFurnitureId || previewFurniture) && (
            <button onClick={onRotate} className="fab bg-blue-500 text-white" title="회전">
              ↻
            </button>
          )}

          {/* 삭제 (가구 선택 시) */}
          {selectedFurnitureId && (
            <button onClick={onDelete} className="fab bg-red-500 text-white" title="삭제">
              ✕
            </button>
          )}

          {/* 취소 (그리기 중) */}
          {(currentWall || tool !== 'select') && (
            <button onClick={onCancel} className="fab bg-gray-600 text-white" title="취소">
              ✕
            </button>
          )}

          {/* Undo/Redo */}
          <div className="flex space-x-2">
            <button
              onClick={onUndo}
              disabled={!canUndo}
              className={`fab ${canUndo ? 'bg-white text-gray-700' : 'bg-gray-100 text-gray-300'}`}
            >
              ↩
            </button>
            <button
              onClick={onRedo}
              disabled={!canRedo}
              className={`fab ${canRedo ? 'bg-white text-gray-700' : 'bg-gray-100 text-gray-300'}`}
            >
              ↪
            </button>
          </div>
        </div>
      );
    };

    // --- 3D 뷰어 컴포넌트 ---
    // 각 벽/방의 개별 재질을 사용하도록 변경 (wallMaterialId, floorMaterialId props 제거)
    const Viewer3D = ({ walls, rooms, openings, furniture = [], isMobile, isTouchDevice }) => {
      const mountRef = useRef(null);
      const [isFPV, setIsFPV] = useState(false);
      const [gender, setGender] = useState('male'); // 'male' | 'female'
      const [isLocked, setIsLocked] = useState(false);
      const [isTouchFPVActive, _setIsTouchFPVActive] = useState(false);
      const isTouchFPVActiveRef = useRef(false);
      const setIsTouchFPVActive = (val) => {
        isTouchFPVActiveRef.current = val;
        _setIsTouchFPVActive(val);
      };

      // Refs for animation loop access
      const sceneRef = useRef(null);
      const cameraRef = useRef(null);
      const rendererRef = useRef(null);
      const controlsRef = useRef(null);
      const fpvControlsRef = useRef(null);
      const requestRef = useRef(null);
      const doorsRef = useRef([]); // 문 애니메이션을 위한 참조
      const ceilingsRef = useRef([]); // 천장 메쉬 참조

      // Movement state
      const moveState = useRef({
        forward: false,
        backward: false,
        left: false,
        right: false,
        velocity: new THREE.Vector3(),
        direction: new THREE.Vector3()
      });

      // 천장 재질만 공통으로 사용 (벽/바닥은 sceneBuilder에서 개별 처리)
      const ceilingTexture = useMemo(() => createCeilingTexture(), []);
      const ceilingMaterial = useMemo(() => new THREE.MeshStandardMaterial({
        map: ceilingTexture,
        roughness: 0.9,
        side: THREE.DoubleSide // 양면 렌더링 (위에서 봐도, 아래서 봐도)
      }), [ceilingTexture]);

      // 충돌 감지 함수 (Imported Wrapper) - offsetX/Z는 useEffect에서 계산됨
      const offsetRef = useRef({ x: 0, z: 0 });
      const checkPlayerCollision = (x, z) => {
        return checkCollision(x, z, walls, openings, offsetRef.current.x, offsetRef.current.z);
      };

      useEffect(() => {
        if (!mountRef.current) return;

        // Scene Setup
        doorsRef.current = []; // 초기화
        ceilingsRef.current = []; // 초기화
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0f2fe); // 하늘색 배경
        scene.fog = new THREE.Fog(0xe0f2fe, 500, 3000); // 안개 효과로 깊이감 추가
        sceneRef.current = scene;

        const container = mountRef.current;
        const containerWidth = container.clientWidth || window.innerWidth;
        const containerHeight = container.clientHeight || (window.innerHeight - (isMobile ? 60 : 80));

        const camera = new THREE.PerspectiveCamera(45, containerWidth / containerHeight, 1, 5000);
        cameraRef.current = camera;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(containerWidth, containerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 부드러운 그림자
        container.appendChild(renderer.domElement);
        rendererRef.current = renderer;

        // Resize handler
        const handleResize = () => {
          const w = container.clientWidth || window.innerWidth;
          const h = container.clientHeight || (window.innerHeight - (isMobile ? 60 : 80));
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          renderer.setSize(w, h);
        };
        window.addEventListener('resize', handleResize);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3); // 벽 색상이 잘 보이도록 밝게
        scene.add(ambientLight);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.3); // 반구 조명도 밝게
        hemiLight.position.set(0, 200, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(500, 1500, 1000);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 5000;
        dirLight.shadow.camera.left = -1500;
        dirLight.shadow.camera.right = 1500;
        dirLight.shadow.camera.top = 1500;
        dirLight.shadow.camera.bottom = -1500;
        dirLight.shadow.bias = -0.0001;
        scene.add(dirLight);



        // Ground (외부 바닥)
        const planeGeometry = new THREE.PlaneGeometry(10000, 10000);
        const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xf9fafb, roughness: 1 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -1;
        plane.receiveShadow = true;
        scene.add(plane);

        const gridHelper = new THREE.GridHelper(5000, 500, 0xcbd5e1, 0xe2e8f0);
        scene.add(gridHelper);

        // Offset - 데이터 바운딩 박스 기반으로 중앙 정렬
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        walls.forEach(w => {
          minX = Math.min(minX, w.start.x, w.end.x);
          maxX = Math.max(maxX, w.start.x, w.end.x);
          minY = Math.min(minY, w.start.y, w.end.y);
          maxY = Math.max(maxY, w.start.y, w.end.y);
        });
        rooms.forEach(r => {
          if (r.points) r.points.forEach(p => {
            minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
            minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
          });
        });
        const dataCenterX = isFinite(minX) ? (minX + maxX) / 2 : 0;
        const dataCenterY = isFinite(minY) ? (minY + maxY) / 2 : 0;
        const offsetX = -dataCenterX;
        const offsetZ = -dataCenterY;
        offsetRef.current = { x: offsetX, z: offsetZ };

        // Build Scene Objects (각 벽/방의 개별 재질 적용)
        rooms.forEach(room => {
          // createRoomObjects 내부에서 room.floorMaterialId를 사용
          const result = createRoomObjects(room, null, ceilingMaterial, offsetX, offsetZ);
          if (result) {
            scene.add(result.floorMesh);
            if (result.ceilingMesh) {
              scene.add(result.ceilingMesh);
              ceilingsRef.current.push(result.ceilingMesh);
            }
          }
        });

        walls.forEach((wall, index) => {
          // createWallObjects 내부에서 wall.materialId를 사용
          const result = createWallObjects(wall, index, openings, null, offsetX, offsetZ);
          if (result.mesh) {
            scene.add(result.mesh);
          }
          if (result.doors.length > 0) {
            doorsRef.current.push(...result.doors);
          }
        });

        furniture.forEach(item => {
          const group = createFurnitureGroup(item, offsetX, offsetZ);
          if (group) {
            scene.add(group);
          }
        });

        // Controls Setup
        const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true;
        controlsRef.current = orbitControls;

        // PointerLockControls: desktop only; mobile uses touch-based FPV
        if (!isTouchDevice) {
          const fpvControls = new THREE.PointerLockControls(camera, renderer.domElement);
          fpvControls.addEventListener('lock', () => setIsLocked(true));
          fpvControls.addEventListener('unlock', () => setIsLocked(false));
          fpvControlsRef.current = fpvControls;
        }

        // Mobile touch FPV camera rotation
        let touchFPVState = { lastX: 0, lastY: 0, active: false };
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const handleTouchFPVStart = (e) => {
          if (!isTouchDevice || e.touches.length !== 1) return;
          touchFPVState.lastX = e.touches[0].clientX;
          touchFPVState.lastY = e.touches[0].clientY;
          touchFPVState.active = true;
        };
        const handleTouchFPVMove = (e) => {
          if (!touchFPVState.active || e.touches.length !== 1) return;
          const dx = e.touches[0].clientX - touchFPVState.lastX;
          const dy = e.touches[0].clientY - touchFPVState.lastY;
          touchFPVState.lastX = e.touches[0].clientX;
          touchFPVState.lastY = e.touches[0].clientY;
          euler.setFromQuaternion(camera.quaternion);
          euler.y -= dx * 0.003;
          euler.x -= dy * 0.003;
          euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
          camera.quaternion.setFromEuler(euler);
        };
        const handleTouchFPVEnd = () => { touchFPVState.active = false; };
        // Attach only during FPV on mobile (handled via ref)
        const touchFPVHandlers = { start: handleTouchFPVStart, move: handleTouchFPVMove, end: handleTouchFPVEnd };
        if (isTouchDevice) {
          renderer.domElement.addEventListener('touchstart', touchFPVHandlers.start, { passive: false });
          renderer.domElement.addEventListener('touchmove', touchFPVHandlers.move, { passive: false });
          renderer.domElement.addEventListener('touchend', touchFPVHandlers.end);
        }

        // Initial Camera Position (Orbit)
        camera.position.set(500, 800, 800);
        camera.lookAt(0, 0, 0);

        let prevTime = performance.now();

        const animate = () => {
          requestRef.current = requestAnimationFrame(animate);

          const time = performance.now();
          const delta = (time - prevTime) / 1000;
          prevTime = time;

          const fpvActive = fpvControlsRef.current ? fpvControlsRef.current.isLocked : isTouchFPVActiveRef.current;
          if (fpvActive) {
            const velocity = moveState.current.velocity;
            const direction = moveState.current.direction;

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            direction.z = Number(moveState.current.forward) - Number(moveState.current.backward);
            direction.x = Number(moveState.current.right) - Number(moveState.current.left);
            direction.normalize();

            if (moveState.current.forward || moveState.current.backward) velocity.z -= direction.z * 4000.0 * delta;
            if (moveState.current.left || moveState.current.right) velocity.x -= direction.x * 4000.0 * delta;

            // --- 충돌 처리 개선 (Move and Revert 방식) ---
            const moveFn = fpvControlsRef.current || null;

            // 1. X축 이동 (좌우)
            const oldX = camera.position.x;
            const oldZ = camera.position.z;

            if (moveFn) {
              moveFn.moveRight(-velocity.x * delta);
            } else {
              // Mobile: manual movement based on camera direction
              const rightVec = new THREE.Vector3();
              camera.getWorldDirection(rightVec);
              rightVec.y = 0;
              rightVec.normalize();
              rightVec.cross(new THREE.Vector3(0, 1, 0));
              camera.position.add(rightVec.multiplyScalar(-velocity.x * delta));
            }

            if (checkPlayerCollision(camera.position.x, camera.position.z)) {
              camera.position.x = oldX;
              camera.position.z = oldZ;
              velocity.x = 0;
            }

            // 2. Z축 이동 (전후)
            const currX = camera.position.x;
            const currZ = camera.position.z;

            if (moveFn) {
              moveFn.moveForward(-velocity.z * delta);
            } else {
              // Mobile: manual forward movement
              const forwardVec = new THREE.Vector3();
              camera.getWorldDirection(forwardVec);
              forwardVec.y = 0;
              forwardVec.normalize();
              camera.position.add(forwardVec.multiplyScalar(-velocity.z * delta));
            }

            if (checkPlayerCollision(camera.position.x, camera.position.z)) {
              camera.position.x = currX;
              camera.position.z = currZ;
              velocity.z = 0;
            }

            // 3. 높이 고정 (비행/땅파기 방지)
            const h = gender === 'male' ? HEIGHT_MALE : HEIGHT_FEMALE;
            camera.position.y = h;

            // FPV 모드일 때 천장 보이기
            if (ceilingsRef.current.length > 0 && !ceilingsRef.current[0].visible) {
              ceilingsRef.current.forEach(c => c.visible = true);
            }
          } else {
            orbitControls.update();

            // Orbit 모드일 때 천장 숨기기
            if (ceilingsRef.current.length > 0 && ceilingsRef.current[0].visible) {
              ceilingsRef.current.forEach(c => c.visible = false);
            }
          }

          // 문 애니메이션 (자동 열림/닫힘)
          if (doorsRef.current.length > 0) {
            const playerPos = camera.position;
            doorsRef.current.forEach(door => {
              const worldPos = new THREE.Vector3();
              door.pivot.getWorldPosition(worldPos);

              // 높이 차이는 무시하고 수평 거리만 계산
              const dist = Math.sqrt(Math.pow(playerPos.x - worldPos.x, 2) + Math.pow(playerPos.z - worldPos.z, 2));

              // 히스테리시스 적용 (열림: 150cm, 닫힘: 250cm)
              const OPEN_DIST = 150;
              const CLOSE_DIST = 250;

              // 상태 초기화
              if (door.targetAngle === undefined) door.targetAngle = 0;
              if (door.isOpen === undefined) door.isOpen = false;

              if (dist < OPEN_DIST) {
                if (!door.isOpen) {
                  // 처음 열릴 때 방향 결정
                  const doorDir = new THREE.Vector3(0, 0, 1); // 문의 로컬 정면 (Z축)
                  doorDir.applyQuaternion(door.pivot.getWorldQuaternion(new THREE.Quaternion()));

                  const toPlayer = new THREE.Vector3().subVectors(playerPos, worldPos).normalize();
                  const dot = doorDir.dot(toPlayer);

                  // 플레이어가 정면(dot > 0)에 있으면 뒤로(-Z방향, +90도) 열림 (Push)
                  // 플레이어가 후면(dot < 0)에 있으면 앞으로(+Z방향, -90도) 열림 (Push)
                  door.targetAngle = dot > 0 ? Math.PI / 2 : -Math.PI / 2;
                  door.isOpen = true;
                }
              } else if (dist > CLOSE_DIST) {
                door.targetAngle = 0;
                door.isOpen = false;
              }

              // 부드럽게 회전 (Lerp 속도 조절: 0.1 -> 0.05)
              door.pivot.rotation.y = THREE.MathUtils.lerp(door.pivot.rotation.y, door.targetAngle, 0.05);
            });
          }

          renderer.render(scene, camera);
        };
        animate();

        // Key handlers for movement
        const onKeyDown = (event) => {
          switch (event.code) {
            case 'ArrowUp': case 'KeyW': moveState.current.forward = true; break;
            case 'ArrowLeft': case 'KeyA': moveState.current.left = true; break;
            case 'ArrowDown': case 'KeyS': moveState.current.backward = true; break;
            case 'ArrowRight': case 'KeyD': moveState.current.right = true; break;
          }
        };
        const onKeyUp = (event) => {
          switch (event.code) {
            case 'ArrowUp': case 'KeyW': moveState.current.forward = false; break;
            case 'ArrowLeft': case 'KeyA': moveState.current.left = false; break;
            case 'ArrowDown': case 'KeyS': moveState.current.backward = false; break;
            case 'ArrowRight': case 'KeyD': moveState.current.right = false; break;
          }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        return () => {
          if (mountRef.current) mountRef.current.innerHTML = '';
          renderer.dispose();
          cancelAnimationFrame(requestRef.current);
          document.removeEventListener('keydown', onKeyDown);
          document.removeEventListener('keyup', onKeyUp);
          window.removeEventListener('resize', handleResize);
          if (isTouchDevice) {
            renderer.domElement.removeEventListener('touchstart', touchFPVHandlers.start);
            renderer.domElement.removeEventListener('touchmove', touchFPVHandlers.move);
            renderer.domElement.removeEventListener('touchend', touchFPVHandlers.end);
          }
        };
      }, [walls, rooms, openings, furniture, ceilingMaterial]);

      // Mode Switching Effect
      useEffect(() => {
        if (!cameraRef.current || !controlsRef.current) return;

        if (isFPV) {
          controlsRef.current.enabled = false;
          const h = gender === 'male' ? HEIGHT_MALE : HEIGHT_FEMALE;
          cameraRef.current.position.y = h;
          cameraRef.current.lookAt(cameraRef.current.position.x, h, cameraRef.current.position.z - 100);
          // Auto-activate FPV on mobile (no PointerLock needed)
          if (isTouchDevice) {
            setIsTouchFPVActive(true);
            setIsLocked(true);
          }
        } else {
          controlsRef.current.enabled = true;
          if (fpvControlsRef.current) fpvControlsRef.current.unlock();
          if (isTouchDevice) {
            setIsTouchFPVActive(false);
            setIsLocked(false);
          }
          cameraRef.current.position.set(500, 800, 800);
          cameraRef.current.lookAt(0, 0, 0);
        }
      }, [isFPV, gender]);

      const toggleLock = () => {
        if (isTouchDevice) {
          setIsTouchFPVActive(true);
          setIsLocked(true);
        } else if (fpvControlsRef.current) {
          fpvControlsRef.current.lock();
        }
      };

      // Joystick handler for mobile FPV
      const handleJoystickMove = useCallback((dx, dy) => {
        moveState.current.forward = dy < -0.2;
        moveState.current.backward = dy > 0.2;
        moveState.current.left = dx < -0.2;
        moveState.current.right = dx > 0.2;
      }, []);

      const handleJoystickEnd = useCallback(() => {
        moveState.current.forward = false;
        moveState.current.backward = false;
        moveState.current.left = false;
        moveState.current.right = false;
      }, []);

      return (
        <div ref={mountRef} className="w-full h-full bg-gray-200 relative">
          <div className="absolute top-4 right-4 z-10 flex flex-col space-y-2">
            <button
              onClick={() => setIsFPV(!isFPV)}
              className={`px-3 py-2 md:px-4 rounded shadow font-bold text-sm md:text-base active:scale-95 transition-transform ${isFPV ? 'bg-green-600 text-white' : 'bg-white text-gray-800'}`}
            >
              {isFPV ? '3D 조감도' : '1인칭 관람'}
            </button>

            {isFPV && (
              <div className="bg-white p-3 md:p-4 rounded shadow-lg flex flex-col space-y-2">
                <p className="text-sm font-bold text-gray-600 mb-2">설정</p>
                <div className="flex space-x-2 bg-gray-100 p-1 rounded">
                  <button
                    onClick={() => setGender('male')}
                    className={`flex-1 py-1 rounded text-sm active:scale-95 ${gender === 'male' ? 'bg-blue-500 text-white' : 'text-gray-600'}`}
                  >
                    남 (180cm)
                  </button>
                  <button
                    onClick={() => setGender('female')}
                    className={`flex-1 py-1 rounded text-sm active:scale-95 ${gender === 'female' ? 'bg-pink-500 text-white' : 'text-gray-600'}`}
                  >
                    여 (160cm)
                  </button>
                </div>

                {!isLocked && (
                  <button
                    onClick={toggleLock}
                    className="w-full py-3 bg-blue-600 text-white rounded font-bold hover:bg-blue-700 active:bg-blue-800 mt-2"
                  >
                    {isTouchDevice ? '터치로 관람 시작' : '관람 시작 (클릭)'}
                  </button>
                )}

                <div className="text-xs text-gray-500 mt-2">
                  {isTouchDevice ? (
                    <>
                      <p>조이스틱: 이동</p>
                      <p>스와이프: 시선</p>
                    </>
                  ) : (
                    <>
                      <p>W,A,S,D: 이동</p>
                      <p>마우스: 시선 이동</p>
                      <p>ESC: 커서 잠금 해제</p>
                    </>
                  )}
                </div>
              </div>
            )}
          </div>
          {isFPV && !isLocked && (
            <div className="absolute inset-0 flex items-center justify-center bg-black/30 z-0 pointer-events-none">
              <div className="text-white text-xl md:text-2xl font-bold drop-shadow-md text-center px-4">
                {isTouchDevice
                  ? "'터치로 관람 시작'을 누르세요"
                  : "우측 상단의 '관람 시작'을 클릭하세요"
                }
              </div>
            </div>
          )}
          {/* Mobile: Virtual Joystick during FPV */}
          {isTouchDevice && isFPV && isLocked && (
            <VirtualJoystick onMove={handleJoystickMove} onEnd={handleJoystickEnd} />
          )}
        </div>
      );
    };

    // --- 툴바 컴포넌트 ---
    const Toolbar = ({ tool, setTool, undo, redo, canUndo, canRedo, clearAll, mode, setMode, handleFileDownload, handleFileUpload, isMobile, onCustomFurniture }) => {
      const [openCategory, setOpenCategory] = useState(null);
      const toolbarRef = useRef(null);

      useEffect(() => {
        const handleClickOutside = (event) => {
          if (toolbarRef.current && !toolbarRef.current.contains(event.target)) {
            setOpenCategory(null);
          }
        };
        document.addEventListener("pointerdown", handleClickOutside);
        return () => {
          document.removeEventListener("pointerdown", handleClickOutside);
        };
      }, [toolbarRef]);

      const handleCategoryClick = (key, category) => {
        if (category.isDirect) {
          setTool(category.items[0].id);
          setOpenCategory(null);
        } else {
          setOpenCategory(openCategory === key ? null : key);
        }
      };

      const handleItemClick = (id) => {
        setTool(id);
        setOpenCategory(null);
      };

      return (
        <div className="bg-white/90 backdrop-blur-md border-b border-gray-200 px-2 md:px-4 py-2 md:py-4 flex justify-between items-center shadow-sm z-10 h-[60px] md:h-[80px]">
          <div className="flex items-center space-x-2 md:space-x-6 flex-1 min-w-0">
            <h1 className="hidden md:block text-2xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-indigo-600 mr-4 flex-shrink-0">
              Floor Planner <span className="text-xs font-medium text-gray-500">Pro</span>
            </h1>

            {/* 메인 툴바 - 모바일에서 가로 스크롤 */}
            <div ref={toolbarRef} className="flex bg-gray-100/50 p-1 md:p-1.5 rounded-xl space-x-1 border border-gray-200 toolbar-scroll flex-shrink min-w-0">
              {TOOLS.map(t => (
                <button
                  key={t.id}
                  onClick={() => setTool(tool === t.id ? 'select' : t.id)}
                  className={`px-2 md:px-3 py-1.5 md:py-2 rounded-lg text-sm font-medium transition-all duration-200 flex items-center space-x-1 md:space-x-2 flex-shrink-0 active:scale-95 ${tool === t.id
                    ? 'bg-white text-blue-600 shadow-md scale-105'
                    : 'text-gray-600 hover:bg-gray-200/80 active:bg-gray-200/80 hover:text-gray-900'
                    }`}
                >
                  <span>{t.icon}</span>
                  <span className="hidden lg:inline">{t.label}</span>
                </button>
              ))}
              <div className="w-px h-6 bg-gray-300 mx-1 md:mx-2 self-center flex-shrink-0"></div>
              {/* 가구 툴바 */}
              {Object.entries(FURNITURE_CATEGORIES).map(([key, category]) => (
                <div key={key} className="relative flex-shrink-0">
                  <button
                    onClick={() => handleCategoryClick(key, category)}
                    className={`p-1.5 md:p-2 rounded-lg text-xs font-medium transition-all duration-200 flex flex-col items-center justify-center w-9 h-9 md:w-10 md:h-10 active:scale-95 ${(openCategory === key || (category.items.some(item => item.id === tool)))
                      ? 'bg-white text-blue-600 shadow-md scale-105'
                      : 'text-gray-600 hover:bg-gray-200/80 active:bg-gray-200/80 hover:text-gray-900'
                      }`}
                    title={category.label}
                  >
                    <span className="text-lg leading-none">{category.icon}</span>
                  </button>
                  {openCategory === key && !category.isDirect && (
                    <div className="absolute top-full mt-2 w-48 max-w-[calc(100vw-2rem)] bg-white rounded-xl shadow-lg border border-gray-100 z-20 p-2">
                      <div className="grid grid-cols-3 gap-2">
                        {category.items.map(item => (
                          <button
                            key={item.id}
                            onClick={() => handleItemClick(item.id)}
                            className={`p-2 rounded-lg text-xs font-medium transition-all duration-200 flex flex-col items-center justify-center w-full h-16 active:scale-95 ${tool === item.id
                              ? 'bg-blue-100 text-blue-700'
                              : 'text-gray-600 hover:bg-gray-100 active:bg-gray-100'
                              }`}
                            title={item.label}
                          >
                            <span className="text-xl leading-none">{item.icon}</span>
                            <span className="text-[10px] mt-1">{item.label}</span>
                          </button>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              ))}
            </div>

            {/* 커스텀 가구 */}
            <div className="bg-gray-100/50 p-1.5 rounded-xl border border-gray-200 flex-shrink-0">
              <button
                onClick={onCustomFurniture}
                className="p-1.5 md:p-2 rounded-lg text-xs font-medium transition-all duration-200 flex flex-col items-center justify-center w-9 h-9 md:w-10 md:h-10 active:scale-95 text-gray-600 hover:bg-gray-200/80 hover:text-gray-900"
                title="커스텀 가구 만들기"
              >
                <span className="text-lg leading-none">➕</span>
              </button>
            </div>

            {/* Undo/Redo - hidden on mobile (using FABs instead) */}
            <div className="hidden md:flex bg-gray-100/50 p-1.5 rounded-xl space-x-1 border border-gray-200 flex-shrink-0">
              <button
                onClick={undo}
                disabled={!canUndo}
                className={`p-2 rounded-lg transition-colors ${canUndo ? 'text-gray-700 hover:bg-white hover:shadow-sm' : 'text-gray-300 cursor-not-allowed'}`}
                title="실행 취소 (Ctrl+Z)"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path></svg>
              </button>
              <button
                onClick={redo}
                disabled={!canRedo}
                className={`p-2 rounded-lg transition-colors ${canRedo ? 'text-gray-700 hover:bg-white hover:shadow-sm' : 'text-gray-300 cursor-not-allowed'}`}
                title="다시 실행 (Ctrl+Y)"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 10h-10a8 8 0 00-8 8v2M21 10l-6 6m6-6l-6-6"></path></svg>
              </button>
            </div>
          </div>

          <div className="flex items-center space-x-1 md:space-x-3 flex-shrink-0">
            <input
              type="file"
              id="file-upload"
              className="hidden"
              accept=".json"
              onChange={handleFileUpload}
            />
            <div className="hidden md:flex bg-gray-100/50 p-1 rounded-lg border border-gray-200">
              <button
                onClick={() => document.getElementById('file-upload').click()}
                className="px-3 py-1.5 rounded-md text-sm font-medium text-gray-600 hover:bg-white hover:shadow-sm transition-all"
                title="JSON 파일 불러오기"
              >
                열기
              </button>
              <button
                onClick={handleFileDownload}
                className="px-3 py-1.5 rounded-md text-sm font-medium text-gray-600 hover:bg-white hover:shadow-sm transition-all"
                title="JSON 파일로 저장"
              >
                저장
              </button>
            </div>

            <div className="hidden md:block w-px h-8 bg-gray-200 mx-2"></div>

            <button onClick={clearAll} className="hidden md:block text-red-500 hover:bg-red-50 active:bg-red-50 px-4 py-2 rounded-lg text-sm font-medium transition-colors">
              초기화
            </button>
            <button
              onClick={() => setMode(mode === '2D' ? '3D' : '2D')}
              className={`px-3 md:px-6 py-2 md:py-2.5 rounded-xl font-bold shadow-lg transition-all transform active:translate-y-0 text-sm md:text-base ${mode === '2D'
                ? 'bg-gradient-to-r from-blue-600 to-indigo-600 text-white'
                : 'bg-white text-gray-800 border border-gray-200'
                }`}
            >
              {mode === '2D' ? '3D' : '2D'}
            </button>
          </div>
        </div>
      );
    };

    const HelpButton = ({ isMobile, isTouchDevice }) => {
      const [showHelp, setShowHelp] = useState(false);

      if (isMobile || isTouchDevice) {
        return (
          <>
            <div className="absolute bottom-6 left-6 z-50">
              <button
                onClick={() => setShowHelp(true)}
                className="w-10 h-10 bg-white rounded-full shadow-lg flex items-center justify-center text-gray-600 active:text-blue-600 active:scale-95 transition-all border border-gray-200"
              >
                <span className="text-lg font-bold">?</span>
              </button>
            </div>
            {showHelp && (
              <div className="modal-overlay" onClick={() => setShowHelp(false)}>
                <div className="modal-content" onClick={e => e.stopPropagation()} style={{ maxWidth: '360px' }}>
                  <h4 className="font-bold text-gray-800 mb-4 text-base">터치 조작 안내</h4>
                  <div className="space-y-3 text-sm text-gray-600 text-left">
                    <div className="flex justify-between"><span>한 손가락</span><span className="text-gray-400">그리기 / 선택</span></div>
                    <div className="flex justify-between"><span>두 손가락 드래그</span><span className="text-gray-400">이동</span></div>
                    <div className="flex justify-between"><span>두 손가락 핀치</span><span className="text-gray-400">확대/축소</span></div>
                    <div className="border-t border-gray-200 my-2 pt-2"></div>
                    <div className="flex justify-between"><span>1인칭 모드</span><span className="text-gray-400">조이스틱: 이동</span></div>
                    <div className="flex justify-between"><span></span><span className="text-gray-400">스와이프: 시선</span></div>
                  </div>
                  <button
                    onClick={() => setShowHelp(false)}
                    className="mt-6 px-6 py-2 bg-blue-500 text-white rounded-lg font-medium active:bg-blue-600"
                  >
                    확인
                  </button>
                </div>
              </div>
            )}
          </>
        );
      }

      return (
        <div className="absolute bottom-6 right-6 z-50 group">
          <button className="w-12 h-12 bg-white rounded-full shadow-lg flex items-center justify-center text-gray-600 hover:text-blue-600 hover:scale-110 transition-all border border-gray-200">
            <span className="text-xl font-bold">?</span>
          </button>
          <div className="absolute bottom-16 right-0 w-64 bg-white/90 backdrop-blur-md p-4 rounded-2xl shadow-xl border border-white/50 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none group-hover:pointer-events-auto transform translate-y-2 group-hover:translate-y-0 duration-200">
            <h4 className="font-bold text-gray-800 mb-3 text-sm">단축키 안내</h4>
            <div className="space-y-2 text-xs text-gray-600">
              <div className="flex justify-between"><span>실행 취소</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Ctrl + Z</kbd></div>
              <div className="flex justify-between"><span>다시 실행</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Ctrl + Y</kbd></div>
              <div className="flex justify-between"><span>회전 (가구)</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">R</kbd></div>
              <div className="flex justify-between"><span>삭제</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Del</kbd></div>
              <div className="flex justify-between"><span>취소</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Esc</kbd></div>
              <div className="border-t border-gray-200 my-2 pt-2"></div>
              <div className="flex justify-between"><span>3D 이동</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">W A S D</kbd></div>
              <div className="flex justify-between"><span>시선 이동</span> <span className="text-gray-500">마우스</span></div>
            </div>
          </div>
        </div>
      );
    };

    // --- 메인 앱 컴포넌트 ---
    const App = () => {
      const { isMobile, isTouchDevice } = useIsMobile();
      const [mode, setMode] = useState('2D');
      const [tool, setTool] = useState('select');
      const [straightMode, setStraightMode] = useState(false);
      const [showConfirmModal, setShowConfirmModal] = useState(false);
      const [showCustomFurnitureModal, setShowCustomFurnitureModal] = useState(false);
      const customFurnitureDims = React.useRef(null);

      // Undo/Redo를 위한 통합 상태 관리
      const { state, pushState, undo, redo, reset, canUndo, canRedo } = useHistory({
        walls: [],
        rooms: [],
        openings: [],
        furniture: []
      });

      const { walls, rooms, openings, furniture } = state;

      // 임시 그리기 상태 (히스토리에 저장 안 함)
      const [currentWall, setCurrentWall] = useState(null);
      const [currentRoom, setCurrentRoom] = useState([]);
      const [previewOpening, setPreviewOpening] = useState(null);
      const [previewFurniture, setPreviewFurniture] = useState(null);
      const [selectedFurnitureId, setSelectedFurnitureId] = useState(null);
      const [isDraggingFurniture, setIsDraggingFurniture] = useState(false);

      // 벽/방 선택 상태
      const [selectedWallIndex, setSelectedWallIndex] = useState(null);
      const [selectedRoomIndex, setSelectedRoomIndex] = useState(null);

      // 뷰포트 상태 (줌 & 팬)
      const [scale, setScale] = useState(1);
      const [pan, setPan] = useState({ x: 0, y: 0 });
      const [isPanning, setIsPanning] = useState(false);
      const [lastMousePos, setLastMousePos] = useState({ x: 0, y: 0 });

      // 모바일 패널 상태
      const [showMaterialSheet, setShowMaterialSheet] = useState(false);

      // 스마트 가이드 상태
      const [guides, setGuides] = useState([]);

      // 터치 핸들러 (모바일 pinch zoom & 2-finger pan)
      const { isTwoFingerGesture } = useTouchHandlers({
        canvasRef,
        scale, setScale, pan, setPan, setIsPanning
      });

      // 재질 선택 상태 (새 벽/방 생성 시 기본값으로 사용)
      const [defaultWallMaterialId, setDefaultWallMaterialId] = useState('white');
      const [defaultFloorMaterialId, setDefaultFloorMaterialId] = useState('wood_oak');

      // 선택된 벽/방의 재질 변경 함수
      const changeWallMaterial = (materialId) => {
        if (selectedWallIndex !== null && walls[selectedWallIndex]) {
          const updatedWalls = walls.map((wall, idx) =>
            idx === selectedWallIndex ? { ...wall, materialId } : wall
          );
          pushState({ ...state, walls: updatedWalls });
        } else {
          setDefaultWallMaterialId(materialId);
        }
      };

      const changeFloorMaterial = (materialId) => {
        if (selectedRoomIndex !== null && rooms[selectedRoomIndex]) {
          const updatedRooms = rooms.map((room, idx) =>
            idx === selectedRoomIndex ? { ...room, floorMaterialId: materialId } : room
          );
          pushState({ ...state, rooms: updatedRooms });
        } else {
          setDefaultFloorMaterialId(materialId);
        }
      };

      // 현재 활성화된 재질 (선택된 객체의 재질 또는 기본값)
      const currentWallMaterialId = selectedWallIndex !== null && walls[selectedWallIndex]
        ? (walls[selectedWallIndex].materialId || 'white')
        : defaultWallMaterialId;
      const currentFloorMaterialId = selectedRoomIndex !== null && rooms[selectedRoomIndex]
        ? (rooms[selectedRoomIndex].floorMaterialId || 'wood_oak')
        : defaultFloorMaterialId;

      const canvasRef = useRef(null);

      const allFurnitureTools = useMemo(() => {
        return Object.values(FURNITURE_CATEGORIES).flatMap(category => category.items);
      }, []);

      const handleCustomFurnitureConfirm = (config) => {
        customFurnitureDims.current = {
          customWidth: config.customWidth,
          customDepth: config.customDepth,
          customHeight: config.customHeight,
          customLabel: config.customLabel,
        };
        setTool(config.type);
        setShowCustomFurnitureModal(false);
      };

      // 단축키 이벤트 핸들러
      useEffect(() => {
        const handleKeyDown = (e) => {
          // Ctrl+Z (Undo), Ctrl+Shift+Z or Ctrl+Y (Redo)
          if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
            if (e.shiftKey) {
              e.preventDefault();
              if (canRedo) redo();
            } else {
              e.preventDefault();
              if (canUndo) undo();
            }
          } else if ((e.metaKey || e.ctrlKey) && e.key === 'y') {
            e.preventDefault();
            if (canRedo) redo();
          } else if (e.code === 'KeyR') {
            // 가구 회전
            if (previewFurniture) {
              setPreviewFurniture(prev => ({
                ...prev,
                rotation: (prev.rotation + Math.PI / 2) % (Math.PI * 2)
              }));
            } else if (selectedFurnitureId) {
              // 선택된 가구 회전
              pushState({
                ...state,
                furniture: furniture.map(f =>
                  f.id === selectedFurnitureId
                    ? { ...f, rotation: (f.rotation + Math.PI / 2) % (Math.PI * 2) }
                    : f
                )
              });
            }
          } else if (e.key === 'Delete' || e.key === 'Backspace') {
            if (selectedFurnitureId) {
              pushState({
                ...state,
                furniture: furniture.filter(f => f.id !== selectedFurnitureId)
              });
              setSelectedFurnitureId(null);
            }
          } else if (e.key === 'Escape') {
            setTool('select');
            setSelectedFurnitureId(null);
            customFurnitureDims.current = null;
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [undo, redo, canUndo, canRedo, previewFurniture, selectedFurnitureId, furniture, state, pushState]);

      // 툴 변경 시 임시 상태 초기화
      useEffect(() => {
        setCurrentWall(null);
        setCurrentRoom([]);
        setPreviewOpening(null);
        setPreviewFurniture(null);
        setSelectedFurnitureId(null);
        // 벽/방 선택은 select 도구일 때만 유지
        if (tool !== 'select') {
          setSelectedWallIndex(null);
          setSelectedRoomIndex(null);
        }
      }, [tool]);

      // --- 데이터 저장/로드 (LocalStorage & File) ---

      // 1. 자동 저장 (Auto Save)
      useEffect(() => {
        const data = { walls, rooms, openings, furniture };
        localStorage.setItem('floorPlanData', JSON.stringify(data));
      }, [walls, rooms, openings, furniture]);

      // 2. 초기 로드 (Auto Load)
      useEffect(() => {
        const savedData = localStorage.getItem('floorPlanData');
        if (savedData) {
          try {
            const parsed = JSON.parse(savedData);
            // 데이터 유효성 검사 (간단히)
            if (parsed.walls && parsed.rooms) {
              reset(parsed);
            }
          } catch (e) {
            console.error("Failed to load saved data", e);
          }
        }
      }, []); // Mount 시 1회 실행

      // 3. 파일 다운로드 핸들러
      const handleFileDownload = () => {
        const data = { walls, rooms, openings, furniture, timestamp: Date.now() };
        downloadFloorPlan(data);
      };

      // 4. 파일 업로드 핸들러
      const handleFileUpload = (e) => {
        const file = e.target.files[0];
        uploadFloorPlan(
          file,
          (parsed) => {
            reset({
              walls: parsed.walls || [],
              rooms: parsed.rooms || [],
              openings: parsed.openings || [],
              furniture: parsed.furniture || []
            });
            showToast("파일을 성공적으로 불러왔습니다.");
          },
          (errorMessage) => {
            showToast(errorMessage);
          }
        );
        // 같은 파일을 다시 선택할 수 있도록 value 초기화
        e.target.value = '';
      };

      // 화면 좌표 -> 월드 좌표 변환
      const screenToWorld = (sx, sy) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const x = (sx - rect.left - pan.x) / scale;
        const y = (sy - rect.top - pan.y) / scale;
        return { x, y };
      };

      // 스마트 스냅 함수 (Imported Wrapper)
      const getSnappedPositionWrapper = (x, y) => {
        return getSnappedPosition(x, y, walls, rooms, scale);
      };

      // 캔버스 렌더링
      useEffect(() => {
        if (mode !== '2D') return;

        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const parent = canvas.parentElement;
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        const displayWidth = parent ? parent.clientWidth : window.innerWidth;
        const displayHeight = parent ? parent.clientHeight : (window.innerHeight - (isMobile ? 60 : 80));

        canvas.width = displayWidth * dpr;
        canvas.height = displayHeight * dpr;
        canvas.style.width = displayWidth + 'px';
        canvas.style.height = displayHeight + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        // 배경
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();

        // 줌 & 팬 적용
        ctx.translate(pan.x, pan.y);
        ctx.scale(scale, scale);

        // 그리드 그리기
        drawGrid(ctx, canvas, scale, pan);

        // 1. 방 그리기 (각 방의 개별 재질 적용)
        rooms.forEach((room, idx) => {
          const isSelected = selectedRoomIndex === idx;
          drawRoom(ctx, room, false, scale, null, isSelected);
        });
        if (currentRoom.length > 0) {
          drawRoom(ctx, currentRoom, true, scale, defaultFloorMaterialId);
          ctx.beginPath();
          ctx.strokeStyle = "blue";
          ctx.setLineDash([5 / scale, 5 / scale]);
          ctx.lineWidth = 2 / scale;
          ctx.moveTo(currentRoom[currentRoom.length - 1].x, currentRoom[currentRoom.length - 1].y);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // 2. 벽 그리기 (각 벽의 개별 재질 적용)
        walls.forEach((wall, idx) => {
          const isSelected = selectedWallIndex === idx;
          drawWall(ctx, wall, 'black', scale, false, null, isSelected);
        });
        if (currentWall) drawWall(ctx, currentWall, 'red', scale, true, defaultWallMaterialId);

        // 3. 오프닝 그리기
        openings.forEach(op => drawOpening(ctx, op, walls, scale));
        if (previewOpening) drawOpening(ctx, previewOpening, walls, scale, true);

        // 4. 가구 그리기
        furniture.forEach(item => {
          // 드래그 중인 가구는 그리지 않음 (previewFurniture로 그려짐)
          if (isDraggingFurniture && item.id === selectedFurnitureId) return;
          drawFurniture(ctx, item, scale, selectedFurnitureId);
        });
        if (previewFurniture) drawFurniture(ctx, previewFurniture, scale, selectedFurnitureId, true);

        // 5. 스마트 가이드 그리기
        if (guides.length > 0) {
          ctx.beginPath();
          ctx.strokeStyle = "#ec4899"; // Pink-500
          ctx.lineWidth = 1 / scale;
          ctx.setLineDash([4 / scale, 4 / scale]);
          guides.forEach(g => {
            if (g.type === 'x') {
              ctx.moveTo(g.pos, -10000); // 화면 전체를 가로지르도록
              ctx.lineTo(g.pos, 10000);
            } else {
              ctx.moveTo(-10000, g.pos);
              ctx.lineTo(10000, g.pos);
            }
          });
          ctx.stroke();
          ctx.setLineDash([]);
        }

        ctx.restore();

      }, [walls, rooms, openings, furniture, currentWall, currentRoom, previewOpening, previewFurniture, mode, scale, pan, guides, selectedWallIndex, selectedRoomIndex, defaultWallMaterialId, defaultFloorMaterialId, isMobile]);



      const handleWheel = useCallback((e) => {
        if (mode !== '2D') return;
        e.preventDefault();

        const zoomSensitivity = 0.001;
        const delta = -e.deltaY * zoomSensitivity;
        const newScale = Math.min(Math.max(0.1, scale + delta), 5);

        const rect = canvasRef.current.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const worldX = (mouseX - pan.x) / scale;
        const worldY = (mouseY - pan.y) / scale;

        const newPanX = mouseX - worldX * newScale;
        const newPanY = mouseY - worldY * newScale;

        setScale(newScale);
        setPan({ x: newPanX, y: newPanY });
      }, [mode, scale, pan, setScale, setPan]);

      useEffect(() => {
        const el = canvasRef.current;
        if (!el) return;
        el.addEventListener('wheel', handleWheel, { passive: false });
        return () => el.removeEventListener('wheel', handleWheel);
      }, [handleWheel]);

      const handlePointerDown = (e) => {
        if (mode !== '2D') return;

        // 2-finger gesture is handled by touch handlers
        if (isTwoFingerGesture()) return;

        // Middle/right button or shift+click for panning (desktop)
        if (e.button === 1 || e.button === 2 || (e.button === 0 && e.shiftKey)) {
          setIsPanning(true);
          setLastMousePos({ x: e.clientX, y: e.clientY });
          return;
        }

        const worldPos = screenToWorld(e.clientX, e.clientY);
        const snapped = getSnappedPositionWrapper(worldPos.x, worldPos.y);
        const x = snapped.x;
        const y = snapped.y;

        if (tool === 'select') {
          // 1. 먼저 가구 선택 시도
          let clickedFurnitureId = null;
          for (let i = furniture.length - 1; i >= 0; i--) {
            const item = furniture[i];
            const dims = getEffectiveDimensions(item);
            if (!dims) continue;

            const dx = worldPos.x - item.x;
            const dy = worldPos.y - item.y;

            // 점을 가구의 로컬 좌표계로 변환 (회전 고려)
            const cos = Math.cos(-item.rotation);
            const sin = Math.sin(-item.rotation);
            const localX = dx * cos - dy * sin;
            const localY = dx * sin + dy * cos;

            if (Math.abs(localX) <= dims.width / 2 && Math.abs(localY) <= dims.depth / 2) {
              clickedFurnitureId = item.id;
              break;
            }
          }

          if (clickedFurnitureId) {
            setSelectedFurnitureId(clickedFurnitureId);
            setSelectedWallIndex(null);
            setSelectedRoomIndex(null);
            setIsDraggingFurniture(true);
            const item = furniture.find(f => f.id === clickedFurnitureId);
            setPreviewFurniture({ ...item });
            return;
          }

          // 2. 방(바닥) 선택 시도 (점이 방 폴리곤 내부에 있는지 확인)
          let clickedRoomIndex = null;
          for (let i = rooms.length - 1; i >= 0; i--) {
            const room = rooms[i];
            if (room.points && isPointInPolygon(worldPos.x, worldPos.y, room.points)) {
              clickedRoomIndex = i;
              break;
            }
          }

          // 3. 벽 선택 시도 (벽에 가까운지 확인)
          let clickedWallIndex = null;
          const wallThreshold = 15 / scale; // 벽에서 15px 이내
          for (let i = walls.length - 1; i >= 0; i--) {
            const wall = walls[i];
            const proj = projectPointOnLine(worldPos, wall.start, wall.end);
            const dist = distance(worldPos, proj);
            if (dist < wallThreshold && proj.t >= 0 && proj.t <= 1) {
              clickedWallIndex = i;
              break;
            }
          }

          // 벽이 선택되면 벽 우선, 아니면 방 선택
          if (clickedWallIndex !== null) {
            setSelectedWallIndex(clickedWallIndex);
            setSelectedRoomIndex(null);
            setSelectedFurnitureId(null);
          } else if (clickedRoomIndex !== null) {
            setSelectedRoomIndex(clickedRoomIndex);
            setSelectedWallIndex(null);
            setSelectedFurnitureId(null);
          } else {
            setSelectedFurnitureId(null);
            setSelectedWallIndex(null);
            setSelectedRoomIndex(null);
          }
        } else if (tool === 'wall') {
          setCurrentWall({ start: { x, y }, end: { x, y } });
        } else if (tool === 'room') {
          setCurrentRoom([{ x, y }, { x, y }, { x, y }, { x, y }]);
        } else if (tool === 'door' || tool === 'window' || tool === 'balcony') {
          if (previewOpening) {
            pushState({
              ...state,
              openings: [...openings, previewOpening]
            });
            setPreviewOpening(null);
          }
        } else if (FURNITURE_TEMPLATES[tool] || customFurnitureDims.current) {
          if (previewFurniture) {
            pushState({
              ...state,
              furniture: [...furniture, { ...previewFurniture, id: Date.now() }]
            });
          }
        }
      };

      const handlePointerMove = (e) => {
        if (mode !== '2D') return;

        // 2-finger gesture is handled by touch handlers
        if (isTwoFingerGesture()) return;

        if (isPanning) {
          const dx = e.clientX - lastMousePos.x;
          const dy = e.clientY - lastMousePos.y;
          setPan(prev => ({ x: prev.x + dx, y: prev.y + dy }));
          setLastMousePos({ x: e.clientX, y: e.clientY });
          return;
        }

        const worldPos = screenToWorld(e.clientX, e.clientY);

        const snapped = getSnappedPositionWrapper(worldPos.x, worldPos.y);
        const x = snapped.x;
        const y = snapped.y;

        if (tool === 'wall' || tool === 'room') {
          setGuides(snapped.guides);
        } else {
          setGuides([]);
        }

        if (tool === 'wall' && currentWall) {
          let targetX = x;
          let targetY = y;

          // Shift key (desktop) or straightMode toggle (mobile) for straight lines
          const useStraight = e.shiftKey || straightMode;
          if (useStraight) {
            const ddx = Math.abs(x - currentWall.start.x);
            const ddy = Math.abs(y - currentWall.start.y);
            // Auto-snap within 15 degrees on mobile
            if (isTouchDevice && !straightMode) {
              const angle = Math.atan2(ddy, ddx) * (180 / Math.PI);
              if (angle < 15) {
                targetY = currentWall.start.y;
              } else if (angle > 75) {
                targetX = currentWall.start.x;
              }
            } else {
              if (ddx > ddy) {
                targetY = currentWall.start.y;
              } else {
                targetX = currentWall.start.x;
              }
            }
          }
          setCurrentWall(prev => ({ ...prev, end: { x: targetX, y: targetY } }));
        } else if (tool === 'room' && currentRoom.length > 0) {
          const start = currentRoom[0];
          const end = { x, y };
          const newPoints = [
            start,
            { x: end.x, y: start.y },
            end,
            { x: start.x, y: end.y }
          ];
          setCurrentRoom(newPoints);
        } else if (tool === 'door' || tool === 'window' || tool === 'balcony') {
          let minDist = 20 / scale;
          let nearest = null;

          walls.forEach((wall, idx) => {
            const proj = projectPointOnLine({ x: worldPos.x, y: worldPos.y }, wall.start, wall.end);
            const d = distance({ x: worldPos.x, y: worldPos.y }, proj);
            if (d < minDist) {
              minDist = d;
              nearest = { wall, idx, t: proj.t };
            }
          });

          if (nearest) {
            setPreviewOpening({
              type: tool,
              wallIndex: nearest.idx,
              t: nearest.t,
              width: tool === 'door' ? DOOR_WIDTH : (tool === 'balcony' ? BALCONY_WIDTH : WINDOW_WIDTH),
              height: tool === 'door' ? DOOR_HEIGHT : (tool === 'balcony' ? BALCONY_HEIGHT : WINDOW_HEIGHT)
            });
          } else {
            setPreviewOpening(null);
          }
        } else if (FURNITURE_TEMPLATES[tool] || customFurnitureDims.current) {
          setPreviewFurniture(prev => ({
            type: tool,
            x,
            y,
            rotation: prev ? prev.rotation : 0,
            ...(customFurnitureDims.current || {})
          }));
        } else if (tool === 'select' && isDraggingFurniture && selectedFurnitureId) {
          // 가구 이동 중 미리보기 업데이트
          setPreviewFurniture({
            ...furniture.find(f => f.id === selectedFurnitureId),
            x, y
          });
        }
      };

      const handlePointerUp = () => {
        if (mode !== '2D') return;

        if (isPanning) {
          setIsPanning(false);
          return;
        }

        if (tool === 'wall' && currentWall) {
          if (currentWall.start.x !== currentWall.end.x || currentWall.start.y !== currentWall.end.y) {
            // 닫힌 영역(방) 감지
            const newRoomPoints = findClosedRegion(walls, currentWall);

            // 벽에 재질 정보 포함
            const wallWithMaterial = { ...currentWall, materialId: defaultWallMaterialId };
            const newWalls = [...walls, wallWithMaterial];
            let newRooms = rooms;

            if (newRoomPoints) {
              // 방이 감지되면 자동으로 추가 (바닥 재질 포함)
              newRooms = [...rooms, { points: newRoomPoints, floorMaterialId: defaultFloorMaterialId }];
            }

            pushState({
              ...state,
              walls: newWalls,
              rooms: newRooms
            });
          }
          setCurrentWall(null);
        } else if (tool === 'room' && currentRoom.length > 0) {
          if (currentRoom[0].x !== currentRoom[2].x || currentRoom[0].y !== currentRoom[2].y) {
            pushState({
              ...state,
              rooms: [...rooms, { points: currentRoom, hasCeiling: false, floorMaterialId: defaultFloorMaterialId }]
            });
          }
          setCurrentRoom([]);
        } else if (tool === 'select' && isDraggingFurniture && selectedFurnitureId && previewFurniture) {
          // 드래그 종료: 변경된 위치 및 회전 저장
          const updatedFurniture = furniture.map(f =>
            f.id === selectedFurnitureId ? { ...f, x: previewFurniture.x, y: previewFurniture.y, rotation: previewFurniture.rotation } : f
          );
          pushState({
            ...state,
            furniture: updatedFurniture
          });
          setIsDraggingFurniture(false);
          setPreviewFurniture(null);
        }
      };

      const handleDoubleClick = () => { };

      const clearAll = () => {
        setShowConfirmModal(true);
      };

      const confirmClearAll = () => {
        reset({ walls: [], rooms: [], openings: [], furniture: [] });
        setCurrentWall(null);
        setCurrentRoom([]);
        setPreviewOpening(null);
        setPreviewFurniture(null);
        setScale(1);
        setPan({ x: 0, y: 0 });
        setShowConfirmModal(false);
      };

      // FAB action handlers
      const handleFABRotate = () => {
        if (previewFurniture) {
          setPreviewFurniture(prev => ({
            ...prev,
            rotation: (prev.rotation + Math.PI / 2) % (Math.PI * 2)
          }));
        } else if (selectedFurnitureId) {
          pushState({
            ...state,
            furniture: furniture.map(f =>
              f.id === selectedFurnitureId
                ? { ...f, rotation: (f.rotation + Math.PI / 2) % (Math.PI * 2) }
                : f
            )
          });
        }
      };

      const handleFABDelete = () => {
        if (selectedFurnitureId) {
          pushState({
            ...state,
            furniture: furniture.filter(f => f.id !== selectedFurnitureId)
          });
          setSelectedFurnitureId(null);
        }
      };

      const handleFABCancel = () => {
        setTool('select');
        setSelectedFurnitureId(null);
      };

      // Material panel content (shared between desktop side panel and mobile bottom sheet)
      const MaterialPanelContent = () => (
        <>
          {(tool === 'wall' || selectedWallIndex !== null) && (
            <>
              <h4 className="font-bold text-gray-800 text-xs mb-3 flex items-center">
                <span className="mr-2">wall</span>
                {selectedWallIndex !== null ? '선택된 벽 재질' : '새 벽 기본 재질'}
              </h4>
              <div className="grid grid-cols-4 gap-2">
                {WALL_MATERIALS.map(mat => (
                  <button
                    key={mat.id}
                    onClick={() => changeWallMaterial(mat.id)}
                    className={`flex flex-col items-center p-1.5 rounded-lg border-2 transition-all active:scale-95 ${currentWallMaterialId === mat.id
                      ? 'border-blue-500 bg-blue-50'
                      : 'border-gray-200 hover:border-gray-400 active:border-gray-400'
                      }`}
                    title={mat.label}
                  >
                    <div className="w-8 h-8 rounded mb-1" style={{ backgroundColor: mat.color }} />
                    <span className="text-[9px] text-gray-600 text-center leading-tight truncate w-full">{mat.label}</span>
                  </button>
                ))}
              </div>
              <p className="text-[10px] text-gray-500 mt-2 pt-2 border-t border-gray-100">
                {selectedWallIndex !== null
                  ? <><span className="text-blue-600">벽 #{selectedWallIndex + 1}</span> - <strong>{WALL_MATERIALS.find(m => m.id === currentWallMaterialId)?.label}</strong></>
                  : <>기본: <strong>{WALL_MATERIALS.find(m => m.id === currentWallMaterialId)?.label}</strong></>
                }
              </p>
            </>
          )}
          {(tool === 'wall' || selectedWallIndex !== null) && (tool === 'room' || selectedRoomIndex !== null) && (
            <div className="border-t border-gray-200 my-3"></div>
          )}
          {(tool === 'room' || selectedRoomIndex !== null) && (
            <>
              <h4 className="font-bold text-gray-800 text-xs mb-3 flex items-center">
                <span className="mr-2">floor</span>
                {selectedRoomIndex !== null ? '선택된 바닥 재질' : '새 바닥 기본 재질'}
              </h4>
              <div className="grid grid-cols-4 gap-2">
                {FLOOR_MATERIALS.map(mat => (
                  <button
                    key={mat.id}
                    onClick={() => changeFloorMaterial(mat.id)}
                    className={`flex flex-col items-center p-1.5 rounded-lg border-2 transition-all active:scale-95 ${currentFloorMaterialId === mat.id
                      ? 'border-blue-500 bg-blue-50'
                      : 'border-gray-200 hover:border-gray-400 active:border-gray-400'
                      }`}
                    title={mat.label}
                  >
                    <div className="w-8 h-8 rounded mb-1" style={{ backgroundColor: mat.color }} />
                    <span className="text-[9px] text-gray-600 text-center leading-tight truncate w-full">{mat.label}</span>
                  </button>
                ))}
              </div>
              <p className="text-[10px] text-gray-500 mt-2 pt-2 border-t border-gray-100">
                {selectedRoomIndex !== null
                  ? <><span className="text-blue-600">바닥 #{selectedRoomIndex + 1}</span> - <strong>{FLOOR_MATERIALS.find(m => m.id === currentFloorMaterialId)?.label}</strong></>
                  : <>기본: <strong>{FLOOR_MATERIALS.find(m => m.id === currentFloorMaterialId)?.label}</strong></>
                }
              </p>
            </>
          )}
        </>
      );

      const showMaterialPanel = tool === 'wall' || tool === 'room' || selectedWallIndex !== null || selectedRoomIndex !== null;

      return (
        <div className="flex flex-col h-screen relative" onContextMenu={(e) => e.preventDefault()}>
          <Toolbar
            tool={tool}
            setTool={setTool}
            undo={undo}
            redo={redo}
            canUndo={canUndo}
            canRedo={canRedo}
            clearAll={clearAll}
            mode={mode}
            setMode={setMode}
            handleFileDownload={handleFileDownload}
            handleFileUpload={handleFileUpload}
            isMobile={isMobile}
            onCustomFurniture={() => setShowCustomFurnitureModal(true)}
          />

          <div className="flex-1 relative overflow-hidden">
            {mode === '2D' ? (
              <div className="w-full h-full bg-white canvas-container"
                style={{ touchAction: 'none' }}
              >
                <canvas
                  ref={canvasRef}
                  onPointerDown={handlePointerDown}
                  onPointerMove={handlePointerMove}
                  onPointerUp={handlePointerUp}
                  onDoubleClick={handleDoubleClick}
                  className="block"
                  style={{ touchAction: 'none' }}
                />
                {/* Desktop: 2D info panels */}
                {!isMobile && (
                  <div className="absolute top-6 left-6 flex items-start gap-4 z-20 pointer-events-none">
                    <div className="bg-white/90 backdrop-blur-md p-4 rounded-2xl shadow-lg border border-white/50 w-64 transition-all duration-300">
                      <div className="flex items-center space-x-2 mb-2">
                        <span className="text-2xl">{TOOLS.find(t => t.id === tool)?.icon || allFurnitureTools.find(t => t.id === tool)?.icon || '👆'}</span>
                        <h3 className="font-bold text-gray-800 text-sm">
                          {TOOLS.find(t => t.id === tool)?.label || allFurnitureTools.find(t => t.id === tool)?.label || '선택 모드'}
                        </h3>
                      </div>
                      <p className="text-xs text-gray-600 leading-relaxed">
                        {tool === 'select' && "객체를 클릭하여 선택하거나 드래그하여 이동하세요."}
                        {tool === 'wall' && "마우스를 드래그하여 벽을 그리세요. Shift를 누르면 수직/수평으로 고정됩니다."}
                        {tool === 'room' && "드래그하여 사각형 방을 만드세요."}
                        {(tool === 'door' || tool === 'window' || tool === 'balcony') && "벽 위에 마우스를 올려 배치하세요."}
                        {FURNITURE_TEMPLATES[tool] && "원하는 위치에 클릭하여 배치하세요."}
                      </p>
                      <div className="mt-3 pt-3 border-t border-gray-100 grid grid-cols-2 gap-2 text-[10px] text-gray-500">
                        <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">mouse</span> 이동/줌</div>
                        {FURNITURE_TEMPLATES[tool] && <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">R</span> 회전</div>}
                        <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">Del</span> 삭제</div>
                        <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">Esc</span> 취소</div>
                      </div>
                    </div>

                    {showMaterialPanel && (
                      <div className="bg-white/95 backdrop-blur-md p-4 rounded-2xl shadow-lg border border-white/50 w-56 pointer-events-auto">
                        <MaterialPanelContent />
                      </div>
                    )}
                  </div>
                )}

                {/* Mobile: material button (opens bottom sheet) */}
                {isMobile && showMaterialPanel && (
                  <button
                    onClick={() => setShowMaterialSheet(!showMaterialSheet)}
                    className="absolute top-3 left-3 z-30 bg-white/90 rounded-full w-10 h-10 flex items-center justify-center shadow-lg border border-gray-200 active:scale-95"
                  >
                    <span className="text-lg">M</span>
                  </button>
                )}

                {/* Mobile: Material bottom sheet */}
                {isMobile && showMaterialSheet && showMaterialPanel && (
                  <div className="bottom-sheet" onClick={() => setShowMaterialSheet(false)}>
                    <div onClick={e => e.stopPropagation()}>
                      <div className="bottom-sheet-handle"></div>
                      <div className="p-4">
                        <MaterialPanelContent />
                      </div>
                    </div>
                  </div>
                )}

                {/* Mobile FABs */}
                {isMobile && (
                  <MobileFABs
                    tool={tool}
                    selectedFurnitureId={selectedFurnitureId}
                    previewFurniture={previewFurniture}
                    onUndo={undo}
                    onRedo={redo}
                    canUndo={canUndo}
                    canRedo={canRedo}
                    onRotate={handleFABRotate}
                    onDelete={handleFABDelete}
                    onCancel={handleFABCancel}
                    onToggleStraight={() => setStraightMode(!straightMode)}
                    straightMode={straightMode}
                    currentWall={currentWall}
                  />
                )}
              </div>
            ) : (
              <>
                <Viewer3D walls={walls} rooms={rooms} openings={openings} furniture={furniture} isMobile={isMobile} isTouchDevice={isTouchDevice} />
                {/* 재질 안내 패널 - hidden on mobile, collapsible */}
                <div className={`absolute top-6 left-6 bg-white/95 backdrop-blur-md p-3 md:p-4 rounded-2xl shadow-lg border border-white/50 z-20 ${isMobile ? 'hidden' : 'w-72'}`}>
                  <h3 className="font-bold text-gray-800 text-sm mb-3 flex items-center">
                    <span className="mr-2">palette</span> 재질 정보
                  </h3>

                  <div className="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-3">
                    <p className="text-xs text-blue-700 leading-relaxed">
                      <strong>Tip:</strong> 2D 편집기에서 벽이나 바닥을 클릭하여 선택한 후 재질을 변경할 수 있습니다.
                    </p>
                  </div>

                  <div className="mb-3">
                    <h4 className="text-xs font-semibold text-gray-600 mb-2">사용된 벽지</h4>
                    <div className="flex flex-wrap gap-1">
                      {[...new Set(walls.map(w => w.materialId || 'white'))].map(matId => {
                        const mat = WALL_MATERIALS.find(m => m.id === matId);
                        return mat ? (
                          <div key={matId} className="flex items-center bg-gray-100 rounded px-2 py-1">
                            <div className="w-4 h-4 rounded mr-1" style={{ backgroundColor: mat.color }}></div>
                            <span className="text-[10px] text-gray-600">{mat.label}</span>
                          </div>
                        ) : null;
                      })}
                      {walls.length === 0 && <span className="text-[10px] text-gray-400">벽 없음</span>}
                    </div>
                  </div>

                  <div>
                    <h4 className="text-xs font-semibold text-gray-600 mb-2">사용된 바닥재</h4>
                    <div className="flex flex-wrap gap-1">
                      {[...new Set(rooms.map(r => r.floorMaterialId || 'wood_oak'))].map(matId => {
                        const mat = FLOOR_MATERIALS.find(m => m.id === matId);
                        return mat ? (
                          <div key={matId} className="flex items-center bg-gray-100 rounded px-2 py-1">
                            <div className="w-4 h-4 rounded mr-1" style={{ backgroundColor: mat.color }}></div>
                            <span className="text-[10px] text-gray-600">{mat.label}</span>
                          </div>
                        ) : null;
                      })}
                      {rooms.length === 0 && <span className="text-[10px] text-gray-400">방 없음</span>}
                    </div>
                  </div>
                </div>
              </>
            )}
            <HelpButton isMobile={isMobile} isTouchDevice={isTouchDevice} />
          </div>

          {/* Confirm Modal */}
          {showConfirmModal && (
            <ConfirmModal
              message="정말 모두 지우시겠습니까?"
              onConfirm={confirmClearAll}
              onCancel={() => setShowConfirmModal(false)}
            />
          )}

          {showCustomFurnitureModal && (
            <CustomFurnitureModal
              onConfirm={handleCustomFurnitureConfirm}
              onCancel={() => setShowCustomFurnitureModal(false)}
            />
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
    // v1.1
  </script>
</body>

</html>