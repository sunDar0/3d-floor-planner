<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Floor Planner</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f3f4f6;
        }

        canvas {
            display: block;
        }

        .canvas-container {
            cursor: crosshair;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.05);
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;
        const { OrbitControls, PointerLockControls } = THREE;

        // ì„¤ì • ê°’
        const GRID_SIZE = 1; // 1cm ë‹¨ìœ„ ì´ë™ (ì •ë°€í•¨)
        const VISUAL_GRID_SIZE = 5; // 5cm ê²©ì í‘œì‹œ
        const WALL_THICKNESS = 15; // 15cm ë²½ ë‘ê»˜
        const WALL_HEIGHT = 240; // 2.4m ë²½ ë†’ì´
        const DOOR_WIDTH = 90; // 90cm ë¬¸ í­
        const DOOR_HEIGHT = 210; // 2.1m ë¬¸ ë†’ì´
        const WINDOW_WIDTH = 120; // 1.2m ì°½ë¬¸ í­
        const WINDOW_HEIGHT = 120; // 1.2m ì°½ë¬¸ ë†’ì´
        const WINDOW_SILL = 90; // ì°½ë¬¸ ë°”ë‹¥ì—ì„œ ë–¨ì–´ì§„ ë†’ì´ (90cm)
        const BALCONY_WIDTH = 240; // 2.4m ë°œì½”ë‹ˆ ì°½
        const BALCONY_HEIGHT = 210; // 2.1m ë°œì½”ë‹ˆ ë†’ì´

        const HEIGHT_MALE = 180;
        const HEIGHT_FEMALE = 160;

        const TOOLS = [
            { id: 'select', icon: 'ğŸ‘†', label: 'ì„ íƒ' },
            { id: 'wall', icon: 'ğŸ§±', label: 'ë²½' },
            { id: 'room', icon: 'â¬›', label: 'ë°©(ë°”ë‹¥)' },
            { id: 'door', icon: 'ğŸšª', label: 'ë¬¸' },
            { id: 'window', icon: 'ğŸªŸ', label: 'ì°½ë¬¸' },
            { id: 'balcony', icon: 'ğŸªŸğŸªŸ', label: 'ë°œì½”ë‹ˆ' },
        ];

        const FURNITURE_TOOLS = [
            { id: 'desk', icon: 'ğŸª‘', label: 'ì±…ìƒ' },
            { id: 'sofa_2p', icon: 'ğŸ›‹ï¸', label: 'ì†ŒíŒŒ(2)' },
            { id: 'sofa_3p', icon: 'ğŸ›‹ï¸', label: 'ì†ŒíŒŒ(3)' },
            { id: 'bed_single', icon: 'ğŸ›ï¸', label: 'ì¹¨ëŒ€(S)' },
            { id: 'bed_queen', icon: 'ğŸ›ï¸', label: 'ì¹¨ëŒ€(Q)' },
            { id: 'bed_king', icon: 'ğŸ›ï¸', label: 'ì¹¨ëŒ€(K)' },
            { id: 'bookshelf_160', icon: 'ğŸ“š', label: 'ì±…ì¥(160)' },
            { id: 'bookshelf_100', icon: 'ğŸ“š', label: 'ì±…ì¥(100)' },
            { id: 'fridge_double', icon: 'ğŸ§Š', label: 'ëƒ‰ì¥ê³ (ì–‘)' },
            { id: 'fridge_single', icon: 'â„ï¸', label: 'ëƒ‰ì¥ê³ (ë‹¨)' },
            { id: 'dining_table_4p', icon: 'ğŸ½ï¸', label: 'ì‹íƒ(4ì¸)' },
            { id: 'dining_table_6p', icon: 'ğŸ½ï¸', label: 'ì‹íƒ(6ì¸)' },
            { id: 'tv_stand', icon: 'ğŸ“º', label: 'TVì¥' },
        ];

        const FURNITURE_TEMPLATES = {
            'desk': { label: 'ì±…ìƒ', width: 160, depth: 80, height: 75, color: 0x8b4513 },
            'sofa_2p': { label: 'ì†ŒíŒŒ 2ì¸', width: 160, depth: 80, height: 85, color: 0x9ca3af },
            'sofa_3p': { label: 'ì†ŒíŒŒ 3ì¸', width: 210, depth: 80, height: 85, color: 0x9ca3af },
            'bed_single': { label: 'ì¹¨ëŒ€ S', width: 100, depth: 200, height: 50, color: 0xffffff },
            'bed_queen': { label: 'ì¹¨ëŒ€ Q', width: 150, depth: 200, height: 50, color: 0xffffff },
            'bed_king': { label: 'ì¹¨ëŒ€ K', width: 180, depth: 200, height: 50, color: 0xffffff },
            'bookshelf_160': { label: 'ì±…ì¥ 160', width: 160, depth: 30, height: 200, color: 0x8b4513 },
            'bookshelf_100': { label: 'ì±…ì¥ 100', width: 100, depth: 30, height: 200, color: 0x8b4513 },
            'fridge_double': { label: 'ëƒ‰ì¥ê³ (ì–‘ë¬¸)', width: 95, depth: 90, height: 185, color: 0xe5e7eb },
            'fridge_single': { label: 'ëƒ‰ì¥ê³ (ë‹¨ë¬¸)', width: 60, depth: 70, height: 185, color: 0xe5e7eb },
            'dining_table_4p': { label: 'ì‹íƒ 4ì¸', width: 120, depth: 80, height: 75, color: 0xd4a373 },
            'dining_table_6p': { label: 'ì‹íƒ 6ì¸', width: 180, depth: 80, height: 75, color: 0xd4a373 },
            'tv_stand': { label: 'TVì¥', width: 180, depth: 40, height: 45, color: 0x8d6e63 },
        };

        // ìœ í‹¸ë¦¬í‹°
        const snapToGrid = (val) => Math.round(val / GRID_SIZE) * GRID_SIZE;

        const distance = (p1, p2) => Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

        // ì ì´ ì„ ë¶„ ìœ„ì— ìˆëŠ”ì§€ í™•ì¸ (íˆ¬ì˜)
        const projectPointOnLine = (point, start, end) => {
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const len2 = dx * dx + dy * dy;
            if (len2 === 0) return start;

            let t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / len2;
            t = Math.max(0, Math.min(1, t));

            return {
                x: start.x + t * dx,
                y: start.y + t * dy,
                t: t // ë¹„ìœ¨ (0~1)
            };
        };

        // --- íˆìŠ¤í† ë¦¬ ê´€ë¦¬ í›… ---
        const useHistory = (initialState) => {
            const [history, setHistory] = useState([initialState]);
            const [currentIndex, setCurrentIndex] = useState(0);

            // ìƒíƒœ ë³€ê²½ (ìƒˆë¡œìš´ ê¸°ë¡ ì¶”ê°€)
            const pushState = useCallback((newState) => {
                setHistory(prevHistory => {
                    const upToCurrent = prevHistory.slice(0, currentIndex + 1);
                    return [...upToCurrent, newState];
                });
                setCurrentIndex(prev => prev + 1);
            }, [currentIndex]);

            // ì‹¤í–‰ ì·¨ì†Œ
            const undo = useCallback(() => {
                setCurrentIndex(prev => Math.max(0, prev - 1));
            }, []);

            // ë‹¤ì‹œ ì‹¤í–‰
            const redo = useCallback(() => {
                setHistory(prevHistory => {
                    setCurrentIndex(prev => Math.min(prevHistory.length - 1, prev + 1));
                    return prevHistory;
                });
            }, []);

            // ì´ˆê¸°í™”
            const reset = useCallback((newState) => {
                setHistory([newState]);
                setCurrentIndex(0);
            }, []);

            return {
                state: history[currentIndex],
                pushState,
                undo,
                redo,
                reset,
                canUndo: currentIndex > 0,
                canRedo: currentIndex < history.length - 1
            };
        };

        // í…ìŠ¤ì²˜ ìƒì„± ìœ í‹¸ë¦¬í‹°
        const createFloorTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // ë² ì´ìŠ¤ ì»¬ëŸ¬
            ctx.fillStyle = '#e5d0b1';
            ctx.fillRect(0, 0, 512, 512);

            // ë‚˜ë¬´ ê²° ë¬´ëŠ¬
            ctx.fillStyle = '#d4b895';
            for (let i = 0; i < 20; i++) {
                const y = i * (512 / 20);
                ctx.fillRect(0, y, 512, 2); // ì¤„ëˆˆ

                // ë‚˜ì´í…Œ ëŠë‚Œ
                for (let j = 0; j < 50; j++) {
                    ctx.globalAlpha = 0.1;
                    ctx.fillStyle = '#8b5a2b';
                    const x = Math.random() * 512;
                    const w = Math.random() * 100;
                    ctx.fillRect(x, y + 2, w, (512 / 20) - 4);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        };

        const createWallTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#f3f4f6';
            ctx.fillRect(0, 0, 512, 512);

            // ë…¸ì´ì¦ˆ
            for (let i = 0; i < 5000; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#e5e7eb';
                ctx.globalAlpha = 0.5;
                ctx.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 1);
            return texture;
            return texture;
        };

        const createCeilingTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // í°ìƒ‰ í…ìŠ¤ì²˜ (ì•½ê°„ì˜ ì§ˆê°)
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, 512, 512);

            // ë¯¸ì„¸í•œ ë…¸ì´ì¦ˆ
            for (let i = 0; i < 10000; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#f1f5f9';
                ctx.globalAlpha = 0.3;
                ctx.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        };

        // --- 3D ë·°ì–´ ì»´í¬ë„ŒíŠ¸ ---
        const Viewer3D = ({ walls, rooms, openings, furniture = [] }) => {
            const mountRef = useRef(null);
            const [isFPV, setIsFPV] = useState(false);
            const [gender, setGender] = useState('male'); // 'male' | 'female'
            const [isLocked, setIsLocked] = useState(false);

            // Refs for animation loop access
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const controlsRef = useRef(null);
            const fpvControlsRef = useRef(null);
            const requestRef = useRef(null);
            const doorsRef = useRef([]); // ë¬¸ ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•œ ì°¸ì¡°
            const ceilingsRef = useRef([]); // ì²œì¥ ë©”ì‰¬ ì°¸ì¡°

            // Movement state
            const moveState = useRef({
                forward: false,
                backward: false,
                left: false,
                right: false,
                velocity: new THREE.Vector3(),
                direction: new THREE.Vector3()
            });

            // useMemoë¡œ í…ìŠ¤ì²˜ ë° ì¬ì§ˆ ìºì‹±
            const floorTexture = useMemo(() => createFloorTexture(), []);
            const wallTexture = useMemo(() => createWallTexture(), []);

            const floorMaterial = useMemo(() => new THREE.MeshStandardMaterial({
                map: floorTexture,
                roughness: 0.8,
                metalness: 0.1,
                side: THREE.DoubleSide
            }), [floorTexture]);

            const wallMaterial = useMemo(() => new THREE.MeshStandardMaterial({
                map: wallTexture,
                roughness: 0.9,
                color: 0xffffff
            }), [wallTexture]);

            const ceilingTexture = useMemo(() => createCeilingTexture(), []);
            const ceilingMaterial = useMemo(() => new THREE.MeshStandardMaterial({
                map: ceilingTexture,
                roughness: 0.9,
                side: THREE.DoubleSide // ì–‘ë©´ ë Œë”ë§ (ìœ„ì—ì„œ ë´ë„, ì•„ë˜ì„œ ë´ë„)
            }), [ceilingTexture]);

            // ì¶©ëŒ ê°ì§€ í•¨ìˆ˜
            const checkCollision = (x, z) => {
                const PLAYER_RADIUS = 30; // 30cm ëª¸í†µ ë°˜ì§€ë¦„
                const THRESHOLD = WALL_THICKNESS / 2 + PLAYER_RADIUS;

                // ì˜¤í”„ì…‹ (ì¤‘ì•™ ì •ë ¬)
                const offsetX = -window.innerWidth / 2;
                const offsetZ = -window.innerHeight / 2;

                const px = x - offsetX;
                const pz = z - offsetZ;

                for (let i = 0; i < walls.length; i++) {
                    const wall = walls[i];

                    const proj = projectPointOnLine({ x: px, y: pz }, wall.start, wall.end);
                    const dist = distance({ x: px, y: pz }, proj);

                    if (dist < THRESHOLD) {
                        // ë²½ê³¼ ì¶©ëŒí–ˆìœ¼ë‚˜, ë¬¸(ì˜¤í”„ë‹)ì´ ìˆëŠ”ì§€ í™•ì¸
                        const wallOpenings = openings.filter(o => o.wallIndex === i);

                        // í•´ë‹¹ ë²½ì˜ ì˜¤í”„ë‹ë“¤ì„ í™•ì¸
                        const dx = wall.end.x - wall.start.x;
                        const dy = wall.end.y - wall.start.y;
                        const len = Math.sqrt(dx * dx + dy * dy);

                        // íˆ¬ì˜ëœ ì§€ì ì˜ ë¹„ìœ¨(t)ì´ ì˜¤í”„ë‹ êµ¬ê°„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                        const isPassingThroughDoor = wallOpenings.some(op => {
                            if (op.type !== 'door' && op.type !== 'balcony') return false; // ì°½ë¬¸ì€ í†µê³¼ ë¶ˆê°€

                            const opWidth = op.type === 'door' ? DOOR_WIDTH : BALCONY_WIDTH;
                            const opPos = op.t * len;
                            const start = opPos - opWidth / 2;
                            const end = opPos + opWidth / 2;

                            const projPos = proj.t * len;

                            // í”Œë ˆì´ì–´ì˜ ë°˜ì§€ë¦„ì„ ê³ ë ¤í•˜ì—¬ ì˜¤í”„ë‹ ë²”ìœ„ ë‚´ì¸ì§€ í™•ì¸ (ì¡°ê¸ˆ ì—¬ìœ  ìˆê²Œ)
                            return projPos >= (start + 10) && projPos <= (end - 10);
                        });

                        if (isPassingThroughDoor) return false; // ë¬¸ì´ë©´ í†µê³¼ ê°€ëŠ¥

                        return true; // ë¬¸ì´ ì•„ë‹ˆë©´ ì¶©ëŒ
                    }
                }
                return false;
            };

            useEffect(() => {
                if (!mountRef.current) return;

                // Scene Setup
                doorsRef.current = []; // ì´ˆê¸°í™”
                ceilingsRef.current = []; // ì´ˆê¸°í™”
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xe0f2fe); // í•˜ëŠ˜ìƒ‰ ë°°ê²½
                scene.fog = new THREE.Fog(0xe0f2fe, 500, 3000); // ì•ˆê°œ íš¨ê³¼ë¡œ ê¹Šì´ê° ì¶”ê°€
                sceneRef.current = scene;

                const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 5000);
                cameraRef.current = camera;

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight - 80);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ë¶€ë“œëŸ¬ìš´ ê·¸ë¦¼ì
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);

                const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
                hemiLight.position.set(0, 200, 0);
                scene.add(hemiLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(500, 1500, 1000);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.camera.near = 0.5;
                dirLight.shadow.camera.far = 5000;
                dirLight.shadow.camera.left = -1500;
                dirLight.shadow.camera.right = 1500;
                dirLight.shadow.camera.top = 1500;
                dirLight.shadow.camera.bottom = -1500;
                dirLight.shadow.bias = -0.0001;
                scene.add(dirLight);



                // Ground (ì™¸ë¶€ ë°”ë‹¥)
                const planeGeometry = new THREE.PlaneGeometry(10000, 10000);
                const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xf9fafb, roughness: 1 });
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = -Math.PI / 2;
                plane.position.y = -1;
                plane.receiveShadow = true;
                scene.add(plane);

                const gridHelper = new THREE.GridHelper(5000, 500, 0xcbd5e1, 0xe2e8f0);
                scene.add(gridHelper);

                // Offset
                const offsetX = -window.innerWidth / 2;
                const offsetZ = -window.innerHeight / 2;

                // Build Scene Objects
                rooms.forEach(room => {
                    if (room.points.length < 3) return;
                    const shape = new THREE.Shape();
                    shape.moveTo(room.points[0].x + offsetX, room.points[0].y + offsetZ);
                    for (let i = 1; i < room.points.length; i++) {
                        shape.lineTo(room.points[i].x + offsetX, room.points[i].y + offsetZ);
                    }
                    shape.lineTo(room.points[0].x + offsetX, room.points[0].y + offsetZ);
                    const geometry = new THREE.ShapeGeometry(shape);

                    // ë°© ë°”ë‹¥ì— í…ìŠ¤ì²˜ ì ìš© (ìºì‹±ëœ ì¬ì§ˆ ì‚¬ìš©)
                    const material = floorMaterial;

                    // UV ë§¤í•‘ ì¡°ì • (í…ìŠ¤ì²˜ ìŠ¤ì¼€ì¼)
                    const posAttribute = geometry.attributes.position;
                    const uvAttribute = geometry.attributes.uv;
                    for (let i = 0; i < posAttribute.count; i++) {
                        const x = posAttribute.getX(i);
                        const y = posAttribute.getY(i);
                        uvAttribute.setXY(i, x / 500, y / 500); // 500 ë‹¨ìœ„ë¡œ ë°˜ë³µ
                    }

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.rotation.x = Math.PI / 2;
                    mesh.position.y = 0.5;
                    mesh.receiveShadow = true;
                    scene.add(mesh);


                    // ì²œì¥ ìƒì„± (Smart Ceiling)
                    const ceilingGeom = new THREE.ShapeGeometry(shape);
                    // UV ë§¤í•‘
                    const cPosAttribute = ceilingGeom.attributes.position;
                    const cUvAttribute = ceilingGeom.attributes.uv;
                    for (let i = 0; i < cPosAttribute.count; i++) {
                        const x = cPosAttribute.getX(i);
                        const y = cPosAttribute.getY(i);
                        cUvAttribute.setXY(i, x / 500, y / 500);
                    }

                    const ceilingMesh = new THREE.Mesh(ceilingGeom, ceilingMaterial);
                    ceilingMesh.rotation.x = Math.PI / 2; // ë°”ë‹¥ê³¼ ê°™ì€ ë°©í–¥ (ë’¤ì§‘í˜ ì£¼ì˜)
                    ceilingMesh.position.y = WALL_HEIGHT; // ë²½ ë†’ì´ì— ë°°ì¹˜
                    ceilingMesh.visible = false; // ê¸°ë³¸ì ìœ¼ë¡œ ìˆ¨ê¹€ (FPVì—ì„œë§Œ í‘œì‹œ)
                    scene.add(ceilingMesh);
                    ceilingsRef.current.push(ceilingMesh);
                });

                walls.forEach((wall, index) => {
                    const wallOpenings = openings.filter(o => o.wallIndex === index);
                    const dx = wall.end.x - wall.start.x;
                    const dy = wall.end.y - wall.start.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);

                    const wallMat = wallMaterial;

                    if (wallOpenings.length === 0) {
                        const geometry = new THREE.BoxGeometry(len, WALL_HEIGHT, WALL_THICKNESS);
                        const mesh = new THREE.Mesh(geometry, wallMat);
                        const cx = (wall.start.x + wall.end.x) / 2;
                        const cz = (wall.start.y + wall.end.y) / 2;
                        mesh.position.set(cx + offsetX, WALL_HEIGHT / 2, cz + offsetZ);
                        mesh.rotation.y = -angle;
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        scene.add(mesh);
                    } else {
                        wallOpenings.sort((a, b) => a.t - b.t);
                        let currentPos = 0;
                        const wallGroup = new THREE.Group();
                        wallGroup.position.set(wall.start.x + offsetX, 0, wall.start.y + offsetZ);
                        wallGroup.rotation.y = -angle;

                        wallOpenings.forEach(op => {
                            const opPos = op.t * len;
                            const opWidth = op.type === 'door' ? DOOR_WIDTH : (op.type === 'balcony' ? BALCONY_WIDTH : WINDOW_WIDTH);
                            const opHeight = op.type === 'door' ? DOOR_HEIGHT : (op.type === 'balcony' ? BALCONY_HEIGHT : WINDOW_HEIGHT);
                            const opY = (op.type === 'door' || op.type === 'balcony') ? 0 : WINDOW_SILL;
                            const start = opPos - opWidth / 2;
                            const end = opPos + opWidth / 2;

                            if (start > currentPos) {
                                const segLen = start - currentPos;
                                const geom = new THREE.BoxGeometry(segLen, WALL_HEIGHT, WALL_THICKNESS);
                                const mesh = new THREE.Mesh(geom, wallMat);
                                mesh.position.set(currentPos + segLen / 2, WALL_HEIGHT / 2, 0);
                                mesh.castShadow = true;
                                mesh.receiveShadow = true;
                                wallGroup.add(mesh);
                            }

                            const headerHeight = WALL_HEIGHT - (opY + opHeight);
                            if (headerHeight > 0) {
                                const geom = new THREE.BoxGeometry(opWidth, headerHeight, WALL_THICKNESS);
                                const mesh = new THREE.Mesh(geom, wallMat);
                                mesh.position.set(opPos, WALL_HEIGHT - headerHeight / 2, 0);
                                mesh.castShadow = true;
                                mesh.receiveShadow = true;
                                wallGroup.add(mesh);
                            }

                            if (opY > 0) {
                                const geom = new THREE.BoxGeometry(opWidth, opY, WALL_THICKNESS);
                                const mesh = new THREE.Mesh(geom, wallMat);
                                mesh.position.set(opPos, opY / 2, 0);
                                mesh.castShadow = true;
                                mesh.receiveShadow = true;
                                wallGroup.add(mesh);
                            }

                            if (op.type === 'door') {
                                // ê²½ì²©(Pivot) ì—­í• ì„ í•  ê·¸ë£¹ ìƒì„±
                                const doorPivot = new THREE.Group();
                                doorPivot.position.set(start, 0, 0); // ì˜¤í”„ë‹ì˜ ì‹œì‘ì (ì™¼ìª½)ì„ ê²½ì²© ìœ„ì¹˜ë¡œ

                                const doorGeom = new THREE.BoxGeometry(opWidth, opHeight, 5);
                                const doorMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.6 });
                                const door = new THREE.Mesh(doorGeom, doorMat);

                                // í”¼ë²— ê¸°ì¤€ ë¬¸ ìœ„ì¹˜ ì¡°ì • (ë¬¸ì˜ ì™¼ìª½ ëì´ í”¼ë²—ì— ì˜¤ë„ë¡ ì¤‘ì‹¬ ì´ë™)
                                door.position.set(opWidth / 2, opHeight / 2, 0);
                                door.castShadow = true;

                                // ì†ì¡ì´ ì¶”ê°€
                                const handleGeom = new THREE.SphereGeometry(3);
                                const handleMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
                                const handle = new THREE.Mesh(handleGeom, handleMat);
                                // ì†ì¡ì´ ìœ„ì¹˜ ìˆ˜ì •: ë†’ì´ëŠ” ì¤‘ì•™(0), ê°€ë¡œëŠ” ëìª½(opWidth/2 - 10)
                                handle.position.set(opWidth / 2 - 10, 0, 5);
                                door.add(handle);
                                const handle2 = handle.clone();
                                handle2.position.z = -5;
                                door.add(handle2);

                                doorPivot.add(door);
                                wallGroup.add(doorPivot);

                                // ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•´ ì°¸ì¡° ì €ì¥
                                doorsRef.current.push({
                                    pivot: doorPivot,
                                    width: opWidth
                                });
                            } else if (op.type === 'balcony') {
                                // ë°œì½”ë‹ˆ ì°½ (ìœ ë¦¬)
                                const winGeom = new THREE.BoxGeometry(opWidth, opHeight, 2);
                                const winMat = new THREE.MeshPhysicalMaterial({
                                    color: 0xa7d3ef, // ì¡°ê¸ˆ ë” ì§„í•œ í•˜ëŠ˜ìƒ‰
                                    transparent: true,
                                    opacity: 0.6, // íˆ¬ëª…ë„ ê°ì†Œ (ë” ì˜ ë³´ì´ê²Œ)
                                    metalness: 0.1,
                                    roughness: 0.1,
                                    transmission: 0.2 // íˆ¬ê³¼ìœ¨ ê°ì†Œ
                                });
                                const win = new THREE.Mesh(winGeom, winMat);
                                win.position.set(opPos, opHeight / 2, 0);

                                // í”„ë ˆì„ ì¶”ê°€ (í…Œë‘ë¦¬)
                                const frameGeom = new THREE.BoxGeometry(opWidth + 4, opHeight + 4, 4);
                                const frameMat = new THREE.MeshStandardMaterial({ color: 0x333333 }); // ì§™ì€ íšŒìƒ‰ í”„ë ˆì„
                                // í”„ë ˆì„ì€ ì†ì´ ë¹„ì–´ìˆì–´ì•¼ í•˜ë¯€ë¡œ 4ê°œì˜ ë§‰ëŒ€ë¡œ êµ¬ì„±í•˜ê±°ë‚˜, ê°„ë‹¨íˆ ë’¤ì— ë§ëŒ€ê¸°ë³´ë‹¤ëŠ”...
                                // ì—¬ê¸°ì„œëŠ” ê°„ë‹¨íˆ ìœ ë¦¬ë§Œ ë” ì˜ ë³´ì´ê²Œ ì²˜ë¦¬í•˜ê³ , í”„ë ˆì„ì€ ìƒëµí•˜ê±°ë‚˜ ê°„ë‹¨í•œ ë ë¡œ í‘œí˜„

                                // ê°„ë‹¨í•œ í”„ë ˆì„ (ìƒí•˜ì¢Œìš°)
                                const frameThick = 4;
                                const frameDepth = 6;
                                const frameGroup = new THREE.Group();
                                frameGroup.position.set(opPos, opHeight / 2, 0);

                                // ìƒ
                                const topFrame = new THREE.Mesh(new THREE.BoxGeometry(opWidth, frameThick, frameDepth), frameMat);
                                topFrame.position.y = opHeight / 2 - frameThick / 2;
                                frameGroup.add(topFrame);
                                // í•˜
                                const bottomFrame = new THREE.Mesh(new THREE.BoxGeometry(opWidth, frameThick, frameDepth), frameMat);
                                bottomFrame.position.y = -opHeight / 2 + frameThick / 2;
                                frameGroup.add(bottomFrame);
                                // ì¢Œ
                                const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThick, opHeight, frameDepth), frameMat);
                                leftFrame.position.x = -opWidth / 2 + frameThick / 2;
                                frameGroup.add(leftFrame);
                                // ìš°
                                const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThick, opHeight, frameDepth), frameMat);
                                rightFrame.position.x = opWidth / 2 - frameThick / 2;
                                frameGroup.add(rightFrame);

                                wallGroup.add(frameGroup);
                                wallGroup.add(win);

                            } else {
                                const winGeom = new THREE.BoxGeometry(opWidth, opHeight, 2);
                                const winMat = new THREE.MeshPhysicalMaterial({
                                    color: 0xa7d3ef,
                                    transparent: true,
                                    opacity: 0.6,
                                    metalness: 0.1,
                                    roughness: 0.1,
                                    transmission: 0.2
                                });
                                const win = new THREE.Mesh(winGeom, winMat);
                                win.position.set(opPos, opY + opHeight / 2, 0);

                                // ì°½ë¬¸ í”„ë ˆì„
                                const frameThick = 4;
                                const frameDepth = 6;
                                const frameMat = new THREE.MeshStandardMaterial({ color: 0xffffff }); // í°ìƒ‰ í”„ë ˆì„
                                const frameGroup = new THREE.Group();
                                frameGroup.position.set(opPos, opY + opHeight / 2, 0);

                                // ìƒ
                                const topFrame = new THREE.Mesh(new THREE.BoxGeometry(opWidth, frameThick, frameDepth), frameMat);
                                topFrame.position.y = opHeight / 2 - frameThick / 2;
                                frameGroup.add(topFrame);
                                // í•˜
                                const bottomFrame = new THREE.Mesh(new THREE.BoxGeometry(opWidth, frameThick, frameDepth), frameMat);
                                bottomFrame.position.y = -opHeight / 2 + frameThick / 2;
                                frameGroup.add(bottomFrame);
                                // ì¢Œ
                                const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThick, opHeight, frameDepth), frameMat);
                                leftFrame.position.x = -opWidth / 2 + frameThick / 2;
                                frameGroup.add(leftFrame);
                                // ìš°
                                const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameThick, opHeight, frameDepth), frameMat);
                                rightFrame.position.x = opWidth / 2 - frameThick / 2;
                                frameGroup.add(rightFrame);

                                wallGroup.add(frameGroup);
                                wallGroup.add(win);
                            }
                            currentPos = end;
                        });

                        if (currentPos < len) {
                            const segLen = len - currentPos;
                            const geom = new THREE.BoxGeometry(segLen, WALL_HEIGHT, WALL_THICKNESS);
                            const mesh = new THREE.Mesh(geom, wallMat);
                            mesh.position.set(currentPos + segLen / 2, WALL_HEIGHT / 2, 0);
                            mesh.castShadow = true;
                            mesh.receiveShadow = true;
                            wallGroup.add(mesh);
                        }
                        scene.add(wallGroup);
                    }
                });

                furniture.forEach(item => {
                    const template = FURNITURE_TEMPLATES[item.type];
                    if (!template) return;
                    const group = new THREE.Group();
                    group.position.set(item.x + offsetX, 0, item.y + offsetZ);
                    group.rotation.y = -item.rotation;
                    const { width, depth, height, color } = template;

                    // ê°€êµ¬ ì¬ì§ˆ (Standard Material)
                    const furnitureMat = new THREE.MeshStandardMaterial({ color, roughness: 0.7 });

                    if (item.type.includes('bed')) {
                        const frameGeom = new THREE.BoxGeometry(width, 30, depth);
                        const frameMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.8 });
                        const frame = new THREE.Mesh(frameGeom, frameMat);
                        frame.position.y = 15;
                        frame.castShadow = true;
                        group.add(frame);

                        const matGeom = new THREE.BoxGeometry(width - 10, 20, depth - 10);
                        const matMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 });
                        const mat = new THREE.Mesh(matGeom, matMat);
                        mat.position.y = 30 + 10;
                        mat.castShadow = true;
                        group.add(mat);

                        const pillowGeom = new THREE.BoxGeometry(width - 20, 10, 30);
                        const pillowMat = new THREE.MeshStandardMaterial({ color: 0xe5e7eb, roughness: 1 });
                        const pillow = new THREE.Mesh(pillowGeom, pillowMat);
                        pillow.position.set(0, 55, -depth / 2 + 25);
                        pillow.castShadow = true;
                        group.add(pillow);

                        const headGeom = new THREE.BoxGeometry(width, 100, 10);
                        const headMat = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.6 });
                        const head = new THREE.Mesh(headGeom, headMat);
                        head.position.set(0, 50, -depth / 2 + 5);
                        head.castShadow = true;
                        group.add(head);
                    } else if (item.type.includes('sofa')) {
                        const seatHeight = 40;
                        const seatGeom = new THREE.BoxGeometry(width, seatHeight, depth - 20);
                        const seatMat = new THREE.MeshStandardMaterial({ color, roughness: 1 }); // íŒ¨ë¸Œë¦­ ëŠë‚Œ
                        const seat = new THREE.Mesh(seatGeom, seatMat);
                        seat.position.set(0, seatHeight / 2, 10);
                        seat.castShadow = true;
                        group.add(seat);

                        const backGeom = new THREE.BoxGeometry(width, height, 20);
                        const back = new THREE.Mesh(backGeom, seatMat);
                        back.position.set(0, height / 2, -depth / 2 + 10);
                        back.castShadow = true;
                        group.add(back);

                        const armGeom = new THREE.BoxGeometry(15, 60, depth);
                        const armLeft = new THREE.Mesh(armGeom, seatMat);
                        armLeft.position.set(-width / 2 + 7.5, 30, 0);
                        group.add(armLeft);

                        const armRight = new THREE.Mesh(armGeom, seatMat);
                        armRight.position.set(width / 2 - 7.5, 30, 0);
                        group.add(armRight);
                    } else if (item.type === 'desk') {
                        const topGeom = new THREE.BoxGeometry(width, 5, depth);
                        const topMat = new THREE.MeshStandardMaterial({ color, roughness: 0.5, metalness: 0.1 });
                        const top = new THREE.Mesh(topGeom, topMat);
                        top.position.y = height - 2.5;
                        top.castShadow = true;
                        group.add(top);

                        const legGeom = new THREE.BoxGeometry(5, height - 5, 5);
                        const legMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.2, metalness: 0.8 });
                        [{ x: -width / 2 + 10, z: -depth / 2 + 10 }, { x: width / 2 - 10, z: -depth / 2 + 10 },
                        { x: -width / 2 + 10, z: depth / 2 - 10 }, { x: width / 2 - 10, z: depth / 2 - 10 }]
                            .forEach(pos => {
                                const leg = new THREE.Mesh(legGeom, legMat);
                                leg.position.set(pos.x, (height - 5) / 2, pos.z);
                                leg.castShadow = true;
                                group.add(leg);
                            });

                        // ì˜ì ì¶”ê°€
                        const chairGroup = new THREE.Group();
                        const chairWidth = 45;
                        const chairDepth = 45;
                        const chairHeight = 45;

                        // ì±…ìƒ ì•ìª½ì— ë°°ì¹˜
                        chairGroup.position.set(0, 0, depth / 2 + 20);
                        chairGroup.rotation.y = Math.PI; // ì±…ìƒì„ ë°”ë¼ë³´ê²Œ

                        // ì¢ŒíŒ
                        const seat = new THREE.Mesh(
                            new THREE.BoxGeometry(chairWidth, 5, chairDepth),
                            new THREE.MeshStandardMaterial({ color: 0x4b5563 }) // ë‹¤í¬ ê·¸ë ˆì´
                        );
                        seat.position.y = chairHeight - 2.5;
                        seat.castShadow = true;
                        chairGroup.add(seat);

                        // ë‹¤ë¦¬ (ì˜¤í”¼ìŠ¤ ì²´ì–´ ìŠ¤íƒ€ì¼)
                        const poleGeom = new THREE.BoxGeometry(5, chairHeight - 10, 5);
                        const pole = new THREE.Mesh(poleGeom, new THREE.MeshStandardMaterial({ color: 0x1f2937 }));
                        pole.position.y = (chairHeight - 10) / 2;
                        chairGroup.add(pole);

                        const baseGeom = new THREE.BoxGeometry(35, 5, 35);
                        const base = new THREE.Mesh(baseGeom, new THREE.MeshStandardMaterial({ color: 0x1f2937 }));
                        base.position.y = 2.5;
                        chairGroup.add(base);

                        // ë“±ë°›ì´
                        const back = new THREE.Mesh(
                            new THREE.BoxGeometry(chairWidth, 45, 5),
                            new THREE.MeshStandardMaterial({ color: 0x4b5563 })
                        );
                        back.position.set(0, chairHeight + 22.5, -chairDepth / 2 + 2.5);
                        back.castShadow = true;
                        chairGroup.add(back);

                        // íŒ”ê±¸ì´
                        const armGeom = new THREE.BoxGeometry(5, 20, 30);
                        const armMat = new THREE.MeshStandardMaterial({ color: 0x1f2937 });

                        const leftArm = new THREE.Mesh(armGeom, armMat);
                        leftArm.position.set(-chairWidth / 2 + 2.5, chairHeight + 10, 0);
                        chairGroup.add(leftArm);

                        const rightArm = new THREE.Mesh(armGeom, armMat);
                        rightArm.position.set(chairWidth / 2 - 2.5, chairHeight + 10, 0);
                        chairGroup.add(rightArm);

                        group.add(chairGroup);
                    } else if (item.type.includes('bookshelf')) {
                        const thickness = 2;
                        const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });

                        // Back
                        const backGeom = new THREE.BoxGeometry(width, height, thickness);
                        const back = new THREE.Mesh(backGeom, mat);
                        back.position.set(0, height / 2, -depth / 2 + thickness / 2);
                        back.castShadow = true;
                        group.add(back);

                        // Sides
                        const sideGeom = new THREE.BoxGeometry(thickness, height, depth);
                        const left = new THREE.Mesh(sideGeom, mat);
                        left.position.set(-width / 2 + thickness / 2, height / 2, 0);
                        left.castShadow = true;
                        group.add(left);

                        const right = new THREE.Mesh(sideGeom, mat);
                        right.position.set(width / 2 - thickness / 2, height / 2, 0);
                        right.castShadow = true;
                        group.add(right);

                        // Shelves
                        const shelfCount = 6;
                        const shelfGeom = new THREE.BoxGeometry(width - thickness * 2, thickness, depth - thickness);
                        for (let i = 0; i < shelfCount; i++) {
                            const shelf = new THREE.Mesh(shelfGeom, mat);
                            const posY = (height - thickness) * (i / (shelfCount - 1)) + thickness / 2;
                            shelf.position.set(0, posY, thickness / 2);
                            shelf.castShadow = true;
                            group.add(shelf);
                        }
                    } else if (item.type.includes('fridge')) {
                        // Body
                        const bodyGeom = new THREE.BoxGeometry(width, height, depth - 5);
                        const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.2, metalness: 0.1 });
                        const body = new THREE.Mesh(bodyGeom, bodyMat);
                        body.position.set(0, height / 2, -2.5);
                        body.castShadow = true;
                        group.add(body);

                        // Doors
                        const doorDepth = 5;
                        const doorGap = 0.5;

                        if (item.type === 'fridge_double') {
                            const doorWidth = (width - doorGap) / 2;
                            const doorGeom = new THREE.BoxGeometry(doorWidth, height, doorDepth);

                            const leftDoor = new THREE.Mesh(doorGeom, bodyMat);
                            leftDoor.position.set(-width / 4 - doorGap / 4, height / 2, depth / 2 - doorDepth / 2);
                            leftDoor.castShadow = true;
                            group.add(leftDoor);

                            const rightDoor = new THREE.Mesh(doorGeom, bodyMat);
                            rightDoor.position.set(width / 4 + doorGap / 4, height / 2, depth / 2 - doorDepth / 2);
                            rightDoor.castShadow = true;
                            group.add(rightDoor);

                            // Handles
                            const handleGeom = new THREE.BoxGeometry(2, 40, 2);
                            const handleMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.1, metalness: 0.8 });

                            const leftHandle = new THREE.Mesh(handleGeom, handleMat);
                            leftHandle.position.set(-5, height / 2, depth / 2 + 1);
                            group.add(leftHandle);

                            const rightHandle = new THREE.Mesh(handleGeom, handleMat);
                            rightHandle.position.set(5, height / 2, depth / 2 + 1);
                            group.add(rightHandle);
                        } else {
                            const doorGeom = new THREE.BoxGeometry(width, height, doorDepth);
                            const door = new THREE.Mesh(doorGeom, bodyMat);
                            door.position.set(0, height / 2, depth / 2 - doorDepth / 2);
                            door.castShadow = true;
                            group.add(door);

                            const handle = new THREE.Mesh(handleGeom, handleMat);
                            handle.position.set(-width / 2 + 10, height / 2, depth / 2 + 1);
                            group.add(handle);
                        }
                    } else if (item.type.includes('dining_table')) {
                        // ìƒíŒ
                        const topGeom = new THREE.BoxGeometry(width, 4, depth);
                        const topMat = new THREE.MeshStandardMaterial({ color, roughness: 0.5 });
                        const top = new THREE.Mesh(topGeom, topMat);
                        top.position.y = height - 2;
                        top.castShadow = true;
                        group.add(top);

                        // ë‹¤ë¦¬ (4ê°œ)
                        const legGeom = new THREE.BoxGeometry(6, height - 4, 6);
                        const legMat = new THREE.MeshStandardMaterial({ color, roughness: 0.5 });
                        const legPos = [
                            { x: -width / 2 + 10, z: -depth / 2 + 10 },
                            { x: width / 2 - 10, z: -depth / 2 + 10 },
                            { x: -width / 2 + 10, z: depth / 2 - 10 },
                            { x: width / 2 - 10, z: depth / 2 - 10 }
                        ];
                        legPos.forEach(pos => {
                            const leg = new THREE.Mesh(legGeom, legMat);
                            leg.position.set(pos.x, (height - 4) / 2, pos.z);
                            leg.castShadow = true;
                            group.add(leg);
                        });

                        // ì˜ì (ê°„ë‹¨í•˜ê²Œ íë¸Œë¡œ í‘œí˜„í•˜ê±°ë‚˜ ë“±ë°›ì´ ìˆëŠ” í˜•íƒœ)
                        const chairWidth = 40;
                        const chairDepth = 40;
                        const chairHeight = 45;

                        const chairCountSide = item.type === 'dining_table_6p' ? 3 : 2;
                        const spacing = width / chairCountSide;

                        for (let side = -1; side <= 1; side += 2) { // ì–‘ìª½ (-1, 1)
                            for (let i = 0; i < chairCountSide; i++) {
                                const chairGroup = new THREE.Group();
                                // ìœ„ì¹˜ ê³„ì‚°: ì¤‘ì•™ ì •ë ¬
                                const x = -width / 2 + spacing / 2 + i * spacing;
                                const z = side * (depth / 2 + 20); // í…Œì´ë¸”ì—ì„œ ì•½ê°„ ë–¨ì–´ì§

                                chairGroup.position.set(x, 0, z);
                                // íšŒì „: í…Œì´ë¸”ì„ ë°”ë¼ë³´ê²Œ
                                chairGroup.rotation.y = side === 1 ? Math.PI : 0;

                                // ì¢ŒíŒ
                                const seat = new THREE.Mesh(
                                    new THREE.BoxGeometry(chairWidth, 5, chairDepth),
                                    new THREE.MeshStandardMaterial({ color: 0xa1887f })
                                );
                                seat.position.y = chairHeight - 2.5;
                                seat.castShadow = true;
                                chairGroup.add(seat);

                                // ë‹¤ë¦¬
                                const cLegGeom = new THREE.BoxGeometry(4, chairHeight - 5, 4);
                                const cLegs = [
                                    { x: -15, z: -15 }, { x: 15, z: -15 },
                                    { x: -15, z: 15 }, { x: 15, z: 15 }
                                ];
                                cLegs.forEach(p => {
                                    const l = new THREE.Mesh(cLegGeom, new THREE.MeshStandardMaterial({ color: 0x8d6e63 }));
                                    l.position.set(p.x, (chairHeight - 5) / 2, p.z);
                                    chairGroup.add(l);
                                });

                                // ë“±ë°›ì´
                                const back = new THREE.Mesh(
                                    new THREE.BoxGeometry(chairWidth, 40, 5),
                                    new THREE.MeshStandardMaterial({ color: 0xa1887f })
                                );
                                back.position.set(0, chairHeight + 20, -chairDepth / 2 + 2.5);
                                back.castShadow = true;
                                chairGroup.add(back);

                                group.add(chairGroup);
                            }
                        }

                    } else if (item.type === 'tv_stand') {
                        // ë³¸ì²´
                        const bodyGeom = new THREE.BoxGeometry(width, height - 10, depth);
                        const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
                        const body = new THREE.Mesh(bodyGeom, bodyMat);
                        body.position.y = (height - 10) / 2 + 10;
                        body.castShadow = true;
                        group.add(body);

                        // ë‹¤ë¦¬
                        const legGeom = new THREE.BoxGeometry(5, 10, 5);
                        const legPos = [
                            { x: -width / 2 + 10, z: -depth / 2 + 10 },
                            { x: width / 2 - 10, z: -depth / 2 + 10 },
                            { x: -width / 2 + 10, z: depth / 2 - 10 },
                            { x: width / 2 - 10, z: depth / 2 - 10 }
                        ];
                        legPos.forEach(pos => {
                            const leg = new THREE.Mesh(legGeom, bodyMat);
                            leg.position.set(pos.x, 5, pos.z);
                            leg.castShadow = true;
                            group.add(leg);
                        });

                        // ì„œë/ë¬¸ ë””í…Œì¼
                        const drawerGeom = new THREE.BoxGeometry(width / 3 - 4, height - 20, 2);
                        const drawerMat = new THREE.MeshStandardMaterial({ color: 0x795548 });
                        for (let i = -1; i <= 1; i++) {
                            const drawer = new THREE.Mesh(drawerGeom, drawerMat);
                            drawer.position.set(i * (width / 3), (height - 10) / 2 + 10, depth / 2 + 1);
                            group.add(drawer);
                        }

                        // TV
                        const tvWidth = 140;
                        const tvHeight = 80;
                        const tvDepth = 5;
                        const tvGeom = new THREE.BoxGeometry(tvWidth, tvHeight, tvDepth);
                        const tvMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2, metalness: 0.8 });
                        const tv = new THREE.Mesh(tvGeom, tvMat);
                        tv.position.set(0, height + tvHeight / 2, 0);
                        tv.castShadow = true;
                        group.add(tv);

                        // TV ë°›ì¹¨ëŒ€
                        const standGeom = new THREE.BoxGeometry(40, 5, 20);
                        const stand = new THREE.Mesh(standGeom, tvMat);
                        stand.position.set(0, height + 2.5, 0);
                        group.add(stand);

                        const neckGeom = new THREE.BoxGeometry(10, 10, 5);
                        const neck = new THREE.Mesh(neckGeom, tvMat);
                        neck.position.set(0, height + 7.5, 0);
                        group.add(neck);
                    }
                    scene.add(group);
                });

                // Controls Setup
                const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
                orbitControls.enableDamping = true;
                controlsRef.current = orbitControls;

                const fpvControls = new THREE.PointerLockControls(camera, renderer.domElement);
                fpvControls.addEventListener('lock', () => setIsLocked(true));
                fpvControls.addEventListener('unlock', () => setIsLocked(false));
                fpvControlsRef.current = fpvControls;

                // Initial Camera Position (Orbit)
                camera.position.set(500, 800, 800);
                camera.lookAt(0, 0, 0);

                let prevTime = performance.now();

                const animate = () => {
                    requestRef.current = requestAnimationFrame(animate);

                    const time = performance.now();
                    const delta = (time - prevTime) / 1000;
                    prevTime = time;

                    if (fpvControls.isLocked) {
                        const velocity = moveState.current.velocity;
                        const direction = moveState.current.direction;

                        velocity.x -= velocity.x * 10.0 * delta;
                        velocity.z -= velocity.z * 10.0 * delta;

                        direction.z = Number(moveState.current.forward) - Number(moveState.current.backward);
                        direction.x = Number(moveState.current.right) - Number(moveState.current.left);
                        direction.normalize();

                        if (moveState.current.forward || moveState.current.backward) velocity.z -= direction.z * 4000.0 * delta;
                        if (moveState.current.left || moveState.current.right) velocity.x -= direction.x * 4000.0 * delta;

                        // --- ì¶©ëŒ ì²˜ë¦¬ ê°œì„  (Move and Revert ë°©ì‹) ---

                        // 1. Xì¶• ì´ë™ (ì¢Œìš°)
                        const oldX = camera.position.x;
                        const oldZ = camera.position.z;

                        fpvControls.moveRight(-velocity.x * delta);

                        if (checkCollision(camera.position.x, camera.position.z)) {
                            camera.position.x = oldX;
                            camera.position.z = oldZ;
                            velocity.x = 0;
                        }

                        // 2. Zì¶• ì´ë™ (ì „í›„)
                        const currX = camera.position.x;
                        const currZ = camera.position.z;

                        fpvControls.moveForward(-velocity.z * delta);

                        if (checkCollision(camera.position.x, camera.position.z)) {
                            camera.position.x = currX;
                            camera.position.z = currZ;
                            velocity.z = 0;
                        }

                        // 3. ë†’ì´ ê³ ì • (ë¹„í–‰/ë•…íŒŒê¸° ë°©ì§€)
                        const h = gender === 'male' ? HEIGHT_MALE : HEIGHT_FEMALE;
                        camera.position.y = h;

                        // FPV ëª¨ë“œì¼ ë•Œ ì²œì¥ ë³´ì´ê¸°
                        if (ceilingsRef.current.length > 0 && !ceilingsRef.current[0].visible) {
                            ceilingsRef.current.forEach(c => c.visible = true);
                        }
                    } else {
                        orbitControls.update();

                        // Orbit ëª¨ë“œì¼ ë•Œ ì²œì¥ ìˆ¨ê¸°ê¸°
                        if (ceilingsRef.current.length > 0 && ceilingsRef.current[0].visible) {
                            ceilingsRef.current.forEach(c => c.visible = false);
                        }
                    }

                    // ë¬¸ ì• ë‹ˆë©”ì´ì…˜ (ìë™ ì—´ë¦¼/ë‹«í˜)
                    if (doorsRef.current.length > 0) {
                        const playerPos = camera.position;
                        doorsRef.current.forEach(door => {
                            const worldPos = new THREE.Vector3();
                            door.pivot.getWorldPosition(worldPos);

                            // ë†’ì´ ì°¨ì´ëŠ” ë¬´ì‹œí•˜ê³  ìˆ˜í‰ ê±°ë¦¬ë§Œ ê³„ì‚°
                            const dist = Math.sqrt(Math.pow(playerPos.x - worldPos.x, 2) + Math.pow(playerPos.z - worldPos.z, 2));

                            // íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ì ìš© (ì—´ë¦¼: 150cm, ë‹«í˜: 250cm)
                            const OPEN_DIST = 150;
                            const CLOSE_DIST = 250;

                            // ìƒíƒœ ì´ˆê¸°í™”
                            if (door.targetAngle === undefined) door.targetAngle = 0;
                            if (door.isOpen === undefined) door.isOpen = false;

                            if (dist < OPEN_DIST) {
                                if (!door.isOpen) {
                                    // ì²˜ìŒ ì—´ë¦´ ë•Œ ë°©í–¥ ê²°ì •
                                    const doorDir = new THREE.Vector3(0, 0, 1); // ë¬¸ì˜ ë¡œì»¬ ì •ë©´ (Zì¶•)
                                    doorDir.applyQuaternion(door.pivot.getWorldQuaternion(new THREE.Quaternion()));

                                    const toPlayer = new THREE.Vector3().subVectors(playerPos, worldPos).normalize();
                                    const dot = doorDir.dot(toPlayer);

                                    // í”Œë ˆì´ì–´ê°€ ì •ë©´(dot > 0)ì— ìˆìœ¼ë©´ ë’¤ë¡œ(-Zë°©í–¥, +90ë„) ì—´ë¦¼ (Push)
                                    // í”Œë ˆì´ì–´ê°€ í›„ë©´(dot < 0)ì— ìˆìœ¼ë©´ ì•ìœ¼ë¡œ(+Zë°©í–¥, -90ë„) ì—´ë¦¼ (Push)
                                    door.targetAngle = dot > 0 ? Math.PI / 2 : -Math.PI / 2;
                                    door.isOpen = true;
                                }
                            } else if (dist > CLOSE_DIST) {
                                door.targetAngle = 0;
                                door.isOpen = false;
                            }

                            // ë¶€ë“œëŸ½ê²Œ íšŒì „ (Lerp ì†ë„ ì¡°ì ˆ: 0.1 -> 0.05)
                            door.pivot.rotation.y = THREE.MathUtils.lerp(door.pivot.rotation.y, door.targetAngle, 0.05);
                        });
                    }

                    renderer.render(scene, camera);
                };
                animate();

                // Key handlers for movement
                const onKeyDown = (event) => {
                    switch (event.code) {
                        case 'ArrowUp': case 'KeyW': moveState.current.forward = true; break;
                        case 'ArrowLeft': case 'KeyA': moveState.current.left = true; break;
                        case 'ArrowDown': case 'KeyS': moveState.current.backward = true; break;
                        case 'ArrowRight': case 'KeyD': moveState.current.right = true; break;
                    }
                };
                const onKeyUp = (event) => {
                    switch (event.code) {
                        case 'ArrowUp': case 'KeyW': moveState.current.forward = false; break;
                        case 'ArrowLeft': case 'KeyA': moveState.current.left = false; break;
                        case 'ArrowDown': case 'KeyS': moveState.current.backward = false; break;
                        case 'ArrowRight': case 'KeyD': moveState.current.right = false; break;
                    }
                };

                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);

                return () => {
                    if (mountRef.current) mountRef.current.innerHTML = '';
                    renderer.dispose();
                    cancelAnimationFrame(requestRef.current);
                    document.removeEventListener('keydown', onKeyDown);
                    document.removeEventListener('keyup', onKeyUp);
                };
            }, [walls, rooms, openings, furniture]);

            // Mode Switching Effect
            useEffect(() => {
                if (!cameraRef.current || !controlsRef.current) return;

                if (isFPV) {
                    controlsRef.current.enabled = false;
                    // Set initial FPV position (center of room or current position if reasonable)
                    // Just reset to a safe height
                    const h = gender === 'male' ? HEIGHT_MALE : HEIGHT_FEMALE;
                    cameraRef.current.position.y = h;
                    cameraRef.current.lookAt(cameraRef.current.position.x, h, cameraRef.current.position.z - 100);
                } else {
                    controlsRef.current.enabled = true;
                    if (fpvControlsRef.current) fpvControlsRef.current.unlock();
                    // Reset to bird's eye view
                    cameraRef.current.position.set(500, 800, 800);
                    cameraRef.current.lookAt(0, 0, 0);
                }
            }, [isFPV, gender]);

            const toggleLock = () => {
                if (fpvControlsRef.current) {
                    fpvControlsRef.current.lock();
                }
            };

            return (
                <div ref={mountRef} className="w-full h-full bg-gray-200 relative">
                    <div className="absolute top-4 right-4 z-10 flex flex-col space-y-2">
                        <button
                            onClick={() => setIsFPV(!isFPV)}
                            className={`px-4 py-2 rounded shadow font-bold ${isFPV ? 'bg-green-600 text-white' : 'bg-white text-gray-800'}`}
                        >
                            {isFPV ? 'ğŸ¦… 3D ì¡°ê°ë„ ëª¨ë“œ' : 'ğŸš¶ 1ì¸ì¹­ ê´€ëŒ ëª¨ë“œ'}
                        </button>

                        {isFPV && (
                            <div className="bg-white p-4 rounded shadow-lg flex flex-col space-y-2">
                                <p className="text-sm font-bold text-gray-600 mb-2">ì„¤ì •</p>
                                <div className="flex space-x-2 bg-gray-100 p-1 rounded">
                                    <button
                                        onClick={() => setGender('male')}
                                        className={`flex-1 py-1 rounded text-sm ${gender === 'male' ? 'bg-blue-500 text-white' : 'text-gray-600'}`}
                                    >
                                        ë‚¨ (180cm)
                                    </button>
                                    <button
                                        onClick={() => setGender('female')}
                                        className={`flex-1 py-1 rounded text-sm ${gender === 'female' ? 'bg-pink-500 text-white' : 'text-gray-600'}`}
                                    >
                                        ì—¬ (160cm)
                                    </button>
                                </div>

                                {!isLocked && (
                                    <button
                                        onClick={toggleLock}
                                        className="w-full py-3 bg-blue-600 text-white rounded font-bold hover:bg-blue-700 mt-2"
                                    >
                                        ê´€ëŒ ì‹œì‘ (í´ë¦­)
                                    </button>
                                )}

                                <div className="text-xs text-gray-500 mt-2">
                                    <p>W,A,S,D: ì´ë™</p>
                                    <p>ë§ˆìš°ìŠ¤: ì‹œì„  ì´ë™</p>
                                    <p>ESC: ì»¤ì„œ ì ê¸ˆ í•´ì œ</p>
                                </div>
                            </div>
                        )}
                    </div>
                    {isFPV && !isLocked && (
                        <div className="absolute inset-0 flex items-center justify-center bg-black/30 z-0 pointer-events-none">
                            <div className="text-white text-2xl font-bold drop-shadow-md">
                                ìš°ì¸¡ ìƒë‹¨ì˜ 'ê´€ëŒ ì‹œì‘'ì„ í´ë¦­í•˜ì„¸ìš”
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- íˆ´ë°” ì»´í¬ë„ŒíŠ¸ ---
        const Toolbar = ({ tool, setTool, undo, redo, canUndo, canRedo, clearAll, mode, setMode, handleFileDownload, handleFileUpload }) => {

            return (
                <div className="bg-white/90 backdrop-blur-md border-b border-gray-200 p-4 flex justify-between items-center shadow-sm z-10 h-[80px]">
                    <div className="flex items-center space-x-6">
                        <h1 className="text-2xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-indigo-600 mr-4">
                            Floor Planner <span className="text-xs font-medium text-gray-500">Pro</span>
                        </h1>

                        {/* ë©”ì¸ íˆ´ë°” */}
                        <div className="flex bg-gray-100/50 p-1.5 rounded-xl space-x-1 border border-gray-200">
                            {TOOLS.map(t => (
                                <button
                                    key={t.id}
                                    onClick={() => setTool(tool === t.id ? 'select' : t.id)}
                                    className={`px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 flex items-center space-x-2 ${tool === t.id
                                        ? 'bg-white text-blue-600 shadow-md scale-105'
                                        : 'text-gray-600 hover:bg-gray-200/80 hover:text-gray-900'
                                        }`}
                                >
                                    <span>{t.icon}</span>
                                    <span className="hidden lg:inline">{t.label}</span>
                                </button>
                            ))}
                            <div className="w-px h-6 bg-gray-300 mx-2 self-center"></div>
                            {/* ê°€êµ¬ íˆ´ë°” */}
                            {FURNITURE_TOOLS.map(t => (
                                <button
                                    key={t.id}
                                    onClick={() => setTool(tool === t.id ? 'select' : t.id)}
                                    className={`p-2 rounded-lg text-xs font-medium transition-all duration-200 flex flex-col items-center justify-center w-10 h-10 ${tool === t.id
                                        ? 'bg-white text-blue-600 shadow-md scale-105'
                                        : 'text-gray-600 hover:bg-gray-200/80 hover:text-gray-900'
                                        }`}
                                    title={t.label}
                                >
                                    <span className="text-lg leading-none">{t.icon}</span>
                                </button>
                            ))}
                        </div>

                        {/* Undo/Redo */}
                        <div className="flex bg-gray-100/50 p-1.5 rounded-xl space-x-1 border border-gray-200">
                            <button
                                onClick={undo}
                                disabled={!canUndo}
                                className={`p-2 rounded-lg transition-colors ${canUndo ? 'text-gray-700 hover:bg-white hover:shadow-sm' : 'text-gray-300 cursor-not-allowed'}`}
                                title="ì‹¤í–‰ ì·¨ì†Œ (Ctrl+Z)"
                            >
                                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path></svg>
                            </button>
                            <button
                                onClick={redo}
                                disabled={!canRedo}
                                className={`p-2 rounded-lg transition-colors ${canRedo ? 'text-gray-700 hover:bg-white hover:shadow-sm' : 'text-gray-300 cursor-not-allowed'}`}
                                title="ë‹¤ì‹œ ì‹¤í–‰ (Ctrl+Y)"
                            >
                                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 10h-10a8 8 0 00-8 8v2M21 10l-6 6m6-6l-6-6"></path></svg>
                            </button>
                        </div>
                    </div>

                    <div className="flex items-center space-x-3">
                        <input
                            type="file"
                            id="file-upload"
                            className="hidden"
                            accept=".json"
                            onChange={handleFileUpload}
                        />
                        <div className="flex bg-gray-100/50 p-1 rounded-lg border border-gray-200">
                            <button
                                onClick={() => document.getElementById('file-upload').click()}
                                className="px-3 py-1.5 rounded-md text-sm font-medium text-gray-600 hover:bg-white hover:shadow-sm transition-all"
                                title="JSON íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°"
                            >
                                ğŸ“‚ ì—´ê¸°
                            </button>
                            <button
                                onClick={handleFileDownload}
                                className="px-3 py-1.5 rounded-md text-sm font-medium text-gray-600 hover:bg-white hover:shadow-sm transition-all"
                                title="JSON íŒŒì¼ë¡œ ì €ì¥"
                            >
                                ğŸ’¾ ì €ì¥
                            </button>
                        </div>

                        <div className="w-px h-8 bg-gray-200 mx-2"></div>

                        <button onClick={clearAll} className="text-red-500 hover:bg-red-50 px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                            ì´ˆê¸°í™”
                        </button>
                        <button
                            onClick={() => setMode(mode === '2D' ? '3D' : '2D')}
                            className={`px-6 py-2.5 rounded-xl font-bold shadow-lg transition-all transform hover:-translate-y-0.5 active:translate-y-0 ${mode === '2D'
                                ? 'bg-gradient-to-r from-blue-600 to-indigo-600 text-white hover:shadow-blue-500/30'
                                : 'bg-white text-gray-800 border border-gray-200 hover:bg-gray-50'
                                }`}
                        >
                            {mode === '2D' ? '3Dë¡œ ë³´ê¸° âœ¨' : '2D í¸ì§‘ê¸°ë¡œ ëŒì•„ê°€ê¸°'}
                        </button>
                    </div>
                </div>
            );
        };

        const HelpButton = () => {
            return (
                <div className="absolute bottom-6 right-6 z-50 group">
                    <button className="w-12 h-12 bg-white rounded-full shadow-lg flex items-center justify-center text-gray-600 hover:text-blue-600 hover:scale-110 transition-all border border-gray-200">
                        <span className="text-xl font-bold">?</span>
                    </button>
                    <div className="absolute bottom-16 right-0 w-64 bg-white/90 backdrop-blur-md p-4 rounded-2xl shadow-xl border border-white/50 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none group-hover:pointer-events-auto transform translate-y-2 group-hover:translate-y-0 duration-200">
                        <h4 className="font-bold text-gray-800 mb-3 text-sm">ë‹¨ì¶•í‚¤ ì•ˆë‚´</h4>
                        <div className="space-y-2 text-xs text-gray-600">
                            <div className="flex justify-between"><span>ì‹¤í–‰ ì·¨ì†Œ</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Ctrl + Z</kbd></div>
                            <div className="flex justify-between"><span>ë‹¤ì‹œ ì‹¤í–‰</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Ctrl + Y</kbd></div>
                            <div className="flex justify-between"><span>íšŒì „ (ê°€êµ¬)</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">R</kbd></div>
                            <div className="flex justify-between"><span>ì‚­ì œ</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Del</kbd></div>
                            <div className="flex justify-between"><span>ì·¨ì†Œ</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Esc</kbd></div>
                            <div className="border-t border-gray-200 my-2 pt-2"></div>
                            <div className="flex justify-between"><span>3D ì´ë™</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">W A S D</kbd></div>
                            <div className="flex justify-between"><span>ì‹œì„  ì´ë™</span> <span className="text-gray-500">ë§ˆìš°ìŠ¤</span></div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- ë©”ì¸ ì•± ì»´í¬ë„ŒíŠ¸ ---
        const App = () => {
            const [mode, setMode] = useState('2D');
            const [tool, setTool] = useState('select'); // 'select', 'wall', 'room', 'door', 'window', 'bed_single', 'desk', etc.

            // Undo/Redoë¥¼ ìœ„í•œ í†µí•© ìƒíƒœ ê´€ë¦¬
            const { state, pushState, undo, redo, reset, canUndo, canRedo } = useHistory({
                walls: [],
                rooms: [],
                openings: [],
                furniture: []
            });

            const { walls, rooms, openings, furniture } = state;

            // ì„ì‹œ ê·¸ë¦¬ê¸° ìƒíƒœ (íˆìŠ¤í† ë¦¬ì— ì €ì¥ ì•ˆ í•¨)
            const [currentWall, setCurrentWall] = useState(null);
            const [currentRoom, setCurrentRoom] = useState([]);
            const [previewOpening, setPreviewOpening] = useState(null);
            const [previewFurniture, setPreviewFurniture] = useState(null); // { type, x, y, rotation }
            const [selectedFurnitureId, setSelectedFurnitureId] = useState(null);
            const [isDraggingFurniture, setIsDraggingFurniture] = useState(false);

            // ë·°í¬íŠ¸ ìƒíƒœ (ì¤Œ & íŒ¬)
            const [scale, setScale] = useState(1);
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [isPanning, setIsPanning] = useState(false);
            const [lastMousePos, setLastMousePos] = useState({ x: 0, y: 0 });

            // ìŠ¤ë§ˆíŠ¸ ê°€ì´ë“œ ìƒíƒœ
            const [guides, setGuides] = useState([]); // [{ type: 'x'|'y', pos: number, start: number, end: number }]

            const canvasRef = useRef(null);

            // ë‹¨ì¶•í‚¤ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
            useEffect(() => {
                const handleKeyDown = (e) => {
                    // Ctrl+Z (Undo), Ctrl+Shift+Z or Ctrl+Y (Redo)
                    if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
                        if (e.shiftKey) {
                            e.preventDefault();
                            if (canRedo) redo();
                        } else {
                            e.preventDefault();
                            if (canUndo) undo();
                        }
                    } else if ((e.metaKey || e.ctrlKey) && e.key === 'y') {
                        e.preventDefault();
                        if (canRedo) redo();
                    } else if (e.code === 'KeyR') {
                        // ê°€êµ¬ íšŒì „
                        if (previewFurniture) {
                            setPreviewFurniture(prev => ({
                                ...prev,
                                rotation: (prev.rotation + Math.PI / 2) % (Math.PI * 2)
                            }));
                        } else if (selectedFurnitureId) {
                            // ì„ íƒëœ ê°€êµ¬ íšŒì „
                            pushState({
                                ...state,
                                furniture: furniture.map(f =>
                                    f.id === selectedFurnitureId
                                        ? { ...f, rotation: (f.rotation + Math.PI / 2) % (Math.PI * 2) }
                                        : f
                                )
                            });
                        }
                    } else if (e.key === 'Delete' || e.key === 'Backspace') {
                        if (selectedFurnitureId) {
                            pushState({
                                ...state,
                                furniture: furniture.filter(f => f.id !== selectedFurnitureId)
                            });
                            setSelectedFurnitureId(null);
                        }
                    } else if (e.key === 'Escape') {
                        setTool('select');
                        setSelectedFurnitureId(null);
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [undo, redo, canUndo, canRedo, previewFurniture, selectedFurnitureId, furniture, state, pushState]);

            // íˆ´ ë³€ê²½ ì‹œ ì„ì‹œ ìƒíƒœ ì´ˆê¸°í™”
            useEffect(() => {
                setCurrentWall(null);
                setCurrentRoom([]);
                setPreviewOpening(null);
                setPreviewFurniture(null);
                setSelectedFurnitureId(null);
            }, [tool]);

            // --- ë°ì´í„° ì €ì¥/ë¡œë“œ (LocalStorage & File) ---

            // 1. ìë™ ì €ì¥ (Auto Save)
            useEffect(() => {
                const data = { walls, rooms, openings, furniture };
                localStorage.setItem('floorPlanData', JSON.stringify(data));
            }, [walls, rooms, openings, furniture]);

            // 2. ì´ˆê¸° ë¡œë“œ (Auto Load)
            useEffect(() => {
                const savedData = localStorage.getItem('floorPlanData');
                if (savedData) {
                    try {
                        const parsed = JSON.parse(savedData);
                        // ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬ (ê°„ë‹¨íˆ)
                        if (parsed.walls && parsed.rooms) {
                            reset(parsed);
                        }
                    } catch (e) {
                        console.error("Failed to load saved data", e);
                    }
                }
            }, []); // Mount ì‹œ 1íšŒ ì‹¤í–‰

            // 3. íŒŒì¼ ë‹¤ìš´ë¡œë“œ í•¸ë“¤ëŸ¬
            const handleFileDownload = () => {
                const data = { walls, rooms, openings, furniture, timestamp: Date.now() };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `floor-plan-${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            // 4. íŒŒì¼ ì—…ë¡œë“œ í•¸ë“¤ëŸ¬
            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const parsed = JSON.parse(event.target.result);
                        if (parsed.walls && parsed.rooms) {
                            reset({
                                walls: parsed.walls || [],
                                rooms: parsed.rooms || [],
                                openings: parsed.openings || [],
                                furniture: parsed.furniture || []
                            });
                            alert("íŒŒì¼ì„ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.");
                        } else {
                            alert("ì˜¬ë°”ë¥´ì§€ ì•Šì€ íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤.");
                        }
                    } catch (err) {
                        console.error(err);
                        alert("íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
                    }
                };
                reader.readAsText(file);
                // ê°™ì€ íŒŒì¼ì„ ë‹¤ì‹œ ì„ íƒí•  ìˆ˜ ìˆë„ë¡ value ì´ˆê¸°í™”
                e.target.value = '';
            };

            // í™”ë©´ ì¢Œí‘œ -> ì›”ë“œ ì¢Œí‘œ ë³€í™˜
            const screenToWorld = (sx, sy) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const x = (sx - rect.left - pan.x) / scale;
                const y = (sy - rect.top - pan.y) / scale;
                return { x, y };
            };

            // ìŠ¤ë§ˆíŠ¸ ìŠ¤ëƒ… í•¨ìˆ˜
            const getSnappedPosition = (x, y) => {
                let sx = snapToGrid(x);
                let sy = snapToGrid(y);
                const SNAP_DIST = 15 / scale; // ìŠ¤ëƒ… ê°ì§€ ê±°ë¦¬ (í™”ë©´ í”½ì…€ ê¸°ì¤€ 15px)

                const newGuides = [];
                let snappedX = false;
                let snappedY = false;

                // ì°¸ì¡°í•  í¬ì¸íŠ¸ ìˆ˜ì§‘ (ë²½ì˜ ì–‘ ëì )
                const points = [];
                walls.forEach(w => {
                    points.push(w.start);
                    points.push(w.end);
                });
                rooms.forEach(r => {
                    r.points.forEach(p => points.push(p));
                });

                // 1. Vertex Snapping (ì  ìŠ¤ëƒ…) - ê°€ì¥ ê°•ë ¥í•œ ìŠ¤ëƒ…
                // ê¸°ì¡´ ì ì— ê°€ê¹Œìš°ë©´ ê·¸ ì ìœ¼ë¡œ ê°•ì œ ì´ë™ (ì¤Œ ì•„ì›ƒ ìƒíƒœì—ì„œë„ ì‰½ê²Œ ì—°ê²° ê°€ëŠ¥)
                for (const p of points) {
                    const dist = Math.sqrt(Math.pow(p.x - x, 2) + Math.pow(p.y - y, 2));
                    if (dist < SNAP_DIST) {
                        return { x: p.x, y: p.y, guides: [] }; // ê°€ì´ë“œ ì—†ì´ ë°”ë¡œ ìŠ¤ëƒ…
                    }
                }

                // 2. Alignment Snapping (ì •ë ¬ ìŠ¤ëƒ…)
                // Xì¶• ìŠ¤ëƒ… (ìˆ˜ì§ì„  ê°€ì´ë“œ) - ë‹¤ë¥¸ ì ì˜ Xì¢Œí‘œì™€ ì¼ì¹˜
                for (const p of points) {
                    if (Math.abs(p.x - x) < SNAP_DIST) {
                        sx = p.x;
                        snappedX = true;
                        newGuides.push({ type: 'x', pos: sx, start: Math.min(y, p.y), end: Math.max(y, p.y) });
                        break; // í•˜ë‚˜ë§Œ ìŠ¤ëƒ…
                    }
                }

                // Yì¶• ìŠ¤ëƒ… (ìˆ˜í‰ì„  ê°€ì´ë“œ) - ë‹¤ë¥¸ ì ì˜ Yì¢Œí‘œì™€ ì¼ì¹˜
                for (const p of points) {
                    if (Math.abs(p.y - y) < SNAP_DIST) {
                        sy = p.y;
                        snappedY = true;
                        newGuides.push({ type: 'y', pos: sy, start: Math.min(x, p.x), end: Math.max(x, p.x) });
                        break;
                    }
                }

                return { x: sx, y: sy, guides: newGuides };
            };

            // ìº”ë²„ìŠ¤ ë Œë”ë§
            useEffect(() => {
                if (mode !== '2D') return;

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');

                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight - 80;

                // ë°°ê²½
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.save();

                // ì¤Œ & íŒ¬ ì ìš©
                ctx.translate(pan.x, pan.y);
                ctx.scale(scale, scale);

                // ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸°
                const startX = Math.floor(-pan.x / scale / VISUAL_GRID_SIZE) * VISUAL_GRID_SIZE;
                const startY = Math.floor(-pan.y / scale / VISUAL_GRID_SIZE) * VISUAL_GRID_SIZE;
                const endX = startX + (canvas.width / scale) + VISUAL_GRID_SIZE;
                const endY = startY + (canvas.height / scale) + VISUAL_GRID_SIZE;

                ctx.beginPath();
                ctx.strokeStyle = "#e5e7eb";
                ctx.lineWidth = 1 / scale;

                for (let x = startX; x <= endX; x += VISUAL_GRID_SIZE) {
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, endY);
                }
                for (let y = startY; y <= endY; y += VISUAL_GRID_SIZE) {
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                }
                ctx.stroke();

                // 1. ë°© ê·¸ë¦¬ê¸°
                rooms.forEach(room => drawRoom(ctx, room.points));
                if (currentRoom.length > 0) {
                    drawRoom(ctx, currentRoom, true);
                    ctx.beginPath();
                    ctx.strokeStyle = "blue";
                    ctx.setLineDash([5 / scale, 5 / scale]);
                    ctx.lineWidth = 2 / scale;
                    ctx.moveTo(currentRoom[currentRoom.length - 1].x, currentRoom[currentRoom.length - 1].y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // 2. ë²½ ê·¸ë¦¬ê¸°
                walls.forEach(wall => drawWall(ctx, wall, 'black'));
                if (currentWall) drawWall(ctx, currentWall, 'red', true);

                // 3. ì˜¤í”„ë‹ ê·¸ë¦¬ê¸°
                openings.forEach(op => drawOpening(ctx, op, walls));
                if (previewOpening) drawOpening(ctx, previewOpening, walls, true);

                // 4. ê°€êµ¬ ê·¸ë¦¬ê¸°
                furniture.forEach(item => {
                    // ë“œë˜ê·¸ ì¤‘ì¸ ê°€êµ¬ëŠ” ê·¸ë¦¬ì§€ ì•ŠìŒ (previewFurnitureë¡œ ê·¸ë ¤ì§)
                    if (isDraggingFurniture && item.id === selectedFurnitureId) return;
                    drawFurniture(ctx, item);
                });
                if (previewFurniture) drawFurniture(ctx, previewFurniture, true);

                // 5. ìŠ¤ë§ˆíŠ¸ ê°€ì´ë“œ ê·¸ë¦¬ê¸°
                if (guides.length > 0) {
                    ctx.beginPath();
                    ctx.strokeStyle = "#ec4899"; // Pink-500
                    ctx.lineWidth = 1 / scale;
                    ctx.setLineDash([4 / scale, 4 / scale]);
                    guides.forEach(g => {
                        if (g.type === 'x') {
                            ctx.moveTo(g.pos, -10000); // í™”ë©´ ì „ì²´ë¥¼ ê°€ë¡œì§€ë¥´ë„ë¡
                            ctx.lineTo(g.pos, 10000);
                        } else {
                            ctx.moveTo(-10000, g.pos);
                            ctx.lineTo(10000, g.pos);
                        }
                    });
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.restore();

            }, [walls, rooms, openings, furniture, currentWall, currentRoom, previewOpening, previewFurniture, mode, scale, pan, guides]);

            const drawRoom = (ctx, points, isPreview = false) => {
                if (points.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                if (!isPreview) ctx.closePath();

                ctx.fillStyle = isPreview ? "rgba(59, 130, 246, 0.2)" : "rgba(224, 231, 255, 0.5)";
                ctx.fill();
                ctx.strokeStyle = isPreview ? "blue" : "#a5b4fc";
                ctx.lineWidth = 2 / scale;
                ctx.stroke();

                points.forEach(p => {
                    ctx.beginPath();
                    ctx.fillStyle = "blue";
                    ctx.arc(p.x, p.y, 3 / scale, 0, Math.PI * 2);
                    ctx.fill();
                });

                // ë°© ì¹˜ìˆ˜ì„  í‘œì‹œ (ê° ë³€ì˜ ê¸¸ì´)
                if (points.length > 1) {
                    ctx.fillStyle = "#6b7280";
                    ctx.font = `${10 / scale}px sans-serif`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";

                    for (let i = 0; i < (isPreview ? points.length - 1 : points.length); i++) {
                        const p1 = points[i];
                        const p2 = points[(i + 1) % points.length];
                        const dist = distance(p1, p2);
                        if (dist > 20) {
                            const midX = (p1.x + p2.x) / 2;
                            const midY = (p1.y + p2.y) / 2;
                            ctx.fillText(`${Math.round(dist)}`, midX, midY);
                        }
                    }
                }
            };

            const drawWall = (ctx, wall, color, isGuide = false) => {
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = (isGuide ? 2 : 4) / scale;
                ctx.lineCap = "round";
                ctx.moveTo(wall.start.x, wall.start.y);
                ctx.lineTo(wall.end.x, wall.end.y);
                ctx.stroke();

                ctx.fillStyle = "#3b82f6";
                ctx.beginPath();
                ctx.arc(wall.start.x, wall.start.y, 4 / scale, 0, Math.PI * 2);
                ctx.arc(wall.end.x, wall.end.y, 4 / scale, 0, Math.PI * 2);
                ctx.fill();

                const dx = wall.end.x - wall.start.x;
                const dy = wall.end.y - wall.start.y;
                const len = Math.sqrt(dx * dx + dy * dy);

                if (len > 5) {
                    const midX = (wall.start.x + wall.end.x) / 2;
                    const midY = (wall.start.y + wall.end.y) / 2;

                    ctx.save();
                    ctx.translate(midX, midY);

                    let angle = Math.atan2(dy, dx);
                    if (angle > Math.PI / 2) angle -= Math.PI;
                    else if (angle < -Math.PI / 2) angle += Math.PI;

                    ctx.rotate(angle);

                    const fontSize = Math.max(12 / scale, 8);
                    ctx.font = `bold ${fontSize}px sans-serif`;
                    ctx.fillStyle = "#4b5563";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "bottom";

                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 3 / scale;
                    const text = Math.round(len) + " cm";
                    ctx.strokeText(text, 0, -4 / scale);
                    ctx.fillText(text, 0, -4 / scale);

                    ctx.restore();
                }
            };

            const drawOpening = (ctx, op, walls, isPreview = false) => {
                const wall = walls[op.wallIndex];
                if (!wall) return;

                const dx = wall.end.x - wall.start.x;
                const dy = wall.end.y - wall.start.y;

                const cx = wall.start.x + dx * op.t;
                const cy = wall.start.y + dy * op.t;

                const angle = Math.atan2(dy, dx);
                const width = op.type === 'door' ? DOOR_WIDTH : (op.type === 'balcony' ? BALCONY_WIDTH : WINDOW_WIDTH);

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angle);

                ctx.fillStyle = "white";
                ctx.fillRect(-width / 2, -4 / scale, width, 8 / scale);

                ctx.strokeStyle = isPreview ? "red" : "brown";
                ctx.lineWidth = 2 / scale;

                if (op.type === 'door') {
                    ctx.beginPath();
                    ctx.arc(-width / 2, -width / 2, width, 0, Math.PI / 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-width / 2, 0);
                    ctx.lineTo(-width / 2, -width);
                    ctx.stroke();
                } else {
                    ctx.strokeRect(-width / 2, -2 / scale, width, 4 / scale);
                    ctx.fillStyle = "#bae6fd";
                    ctx.fillRect(-width / 2, -2 / scale, width, 4 / scale);

                    // ë°œì½”ë‹ˆëŠ” ì¤‘ê°„ì— ì„  ì¶”ê°€ (ìŠ¬ë¼ì´ë”© ë„ì–´ ëŠë‚Œ)
                    if (op.type === 'balcony') {
                        ctx.beginPath();
                        ctx.moveTo(0, -2 / scale);
                        ctx.lineTo(0, 2 / scale);
                        ctx.stroke();
                    }
                }

                ctx.restore();
            };

            const drawFurniture = (ctx, item, isPreview = false) => {
                const template = FURNITURE_TEMPLATES[item.type];
                if (!template) return;

                const isSelected = item.id === selectedFurnitureId;

                ctx.save();
                ctx.translate(item.x, item.y);
                ctx.rotate(item.rotation);

                const { width, depth, label } = template;

                ctx.beginPath();
                ctx.rect(-width / 2, -depth / 2, width, depth);

                ctx.fillStyle = isPreview ? "rgba(100, 100, 100, 0.5)" : (isSelected ? "#bfdbfe" : "#e5e7eb"); // ì„ íƒ ì‹œ ì—°í•œ íŒŒë€ìƒ‰
                ctx.fill();
                ctx.strokeStyle = isPreview ? "blue" : (isSelected ? "#2563eb" : "#4b5563"); // ì„ íƒ ì‹œ ì§„í•œ íŒŒë€ìƒ‰
                ctx.lineWidth = (isSelected ? 3 : 2) / scale;
                ctx.stroke();

                // ì„ íƒëœ ê²½ìš° ëª¨ì„œë¦¬ í•¸ë“¤ í‘œì‹œ (ì‹œê°ì  íš¨ê³¼ë§Œ)
                if (isSelected) {
                    ctx.fillStyle = "#2563eb";
                    const handleSize = 6 / scale;
                    ctx.fillRect(-width / 2 - handleSize / 2, -depth / 2 - handleSize / 2, handleSize, handleSize);
                    ctx.fillRect(width / 2 - handleSize / 2, -depth / 2 - handleSize / 2, handleSize, handleSize);
                    ctx.fillRect(width / 2 - handleSize / 2, depth / 2 - handleSize / 2, handleSize, handleSize);
                    ctx.fillRect(-width / 2 - handleSize / 2, depth / 2 - handleSize / 2, handleSize, handleSize);
                }

                // ë°©í–¥ í‘œì‹œ (ì•ìª½)
                ctx.beginPath();
                ctx.moveTo(-width / 4, depth / 2 - 5);
                ctx.lineTo(width / 4, depth / 2 - 5);
                ctx.stroke();

                // í…ìŠ¤íŠ¸
                ctx.fillStyle = "#000";
                ctx.font = `${12 / scale}px sans-serif`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.save();
                ctx.rotate(-item.rotation); // í…ìŠ¤íŠ¸ëŠ” ì •ë°©í–¥ ìœ ì§€
                ctx.fillText(label, 0, 0);
                ctx.restore();

                ctx.restore();
            };

            const handleWheel = (e) => {
                if (mode !== '2D') return;
                e.preventDefault();

                const zoomSensitivity = 0.001;
                const delta = -e.deltaY * zoomSensitivity;
                const newScale = Math.min(Math.max(0.1, scale + delta), 5);

                const rect = canvasRef.current.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const worldX = (mouseX - pan.x) / scale;
                const worldY = (mouseY - pan.y) / scale;

                const newPanX = mouseX - worldX * newScale;
                const newPanY = mouseY - worldY * newScale;

                setScale(newScale);
                setPan({ x: newPanX, y: newPanY });
            };

            const handleMouseDown = (e) => {
                if (mode !== '2D') return;

                if (e.button === 1 || e.button === 2 || (e.button === 0 && e.shiftKey)) {
                    setIsPanning(true);
                    setLastMousePos({ x: e.clientX, y: e.clientY });
                    return;
                }

                const worldPos = screenToWorld(e.clientX, e.clientY);
                // ë§ˆìš°ìŠ¤ ë‹¤ìš´ ì‹œì—ë„ ìŠ¤ëƒ… ì ìš© (ì‹œì‘ì  ìŠ¤ëƒ…)
                const snapped = getSnappedPosition(worldPos.x, worldPos.y);
                const x = snapped.x;
                const y = snapped.y;

                if (tool === 'select') {
                    // ê°€êµ¬ ì„ íƒ ë¡œì§ (MouseDownì—ì„œ ì²˜ë¦¬)
                    let clickedFurnitureId = null;
                    for (let i = furniture.length - 1; i >= 0; i--) {
                        const item = furniture[i];
                        const template = FURNITURE_TEMPLATES[item.type];
                        if (!template) continue;

                        const dx = worldPos.x - item.x;
                        const dy = worldPos.y - item.y;

                        // ì ì„ ê°€êµ¬ì˜ ë¡œì»¬ ì¢Œí‘œê³„ë¡œ ë³€í™˜ (íšŒì „ ê³ ë ¤)
                        const cos = Math.cos(-item.rotation);
                        const sin = Math.sin(-item.rotation);
                        const localX = dx * cos - dy * sin;
                        const localY = dx * sin + dy * cos;

                        if (Math.abs(localX) <= template.width / 2 && Math.abs(localY) <= template.depth / 2) {
                            clickedFurnitureId = item.id;
                            break;
                        }
                    }

                    if (clickedFurnitureId) {
                        setSelectedFurnitureId(clickedFurnitureId);
                        setIsDraggingFurniture(true);
                        // ë“œë˜ê·¸ ì‹œì‘ ì‹œ ë¯¸ë¦¬ë³´ê¸° ì„¤ì • (ì„ íƒì )
                        const item = furniture.find(f => f.id === clickedFurnitureId);
                        setPreviewFurniture({ ...item });
                    } else {
                        setSelectedFurnitureId(null);
                    }
                } else if (tool === 'wall') {
                    setCurrentWall({ start: { x, y }, end: { x, y } });
                } else if (tool === 'room') {
                    setCurrentRoom([{ x, y }, { x, y }, { x, y }, { x, y }]);
                } else if (tool === 'door' || tool === 'window' || tool === 'balcony') {
                    if (previewOpening) {
                        pushState({
                            ...state,
                            openings: [...openings, previewOpening]
                        });
                        setPreviewOpening(null);
                    }
                } else if (FURNITURE_TEMPLATES[tool]) {
                    if (previewFurniture) {
                        pushState({
                            ...state,
                            furniture: [...furniture, { ...previewFurniture, id: Date.now() }]
                        });
                    }
                }
            };

            const handleMouseMove = (e) => {
                if (mode !== '2D') return;

                if (isPanning) {
                    const dx = e.clientX - lastMousePos.x;
                    const dy = e.clientY - lastMousePos.y;
                    setPan(prev => ({ x: prev.x + dx, y: prev.y + dy }));
                    setLastMousePos({ x: e.clientX, y: e.clientY });
                    return;
                }

                const worldPos = screenToWorld(e.clientX, e.clientY);

                // ìŠ¤ë§ˆíŠ¸ ìŠ¤ëƒ… ì ìš©
                const snapped = getSnappedPosition(worldPos.x, worldPos.y);
                const x = snapped.x;
                const y = snapped.y;

                // ê°€ì´ë“œë¼ì¸ ì—…ë°ì´íŠ¸ (ë²½ì´ë‚˜ ë°© ê·¸ë¦¬ê¸° ë„êµ¬ì¼ ë•Œë§Œ)
                if (tool === 'wall' || tool === 'room') {
                    setGuides(snapped.guides);
                } else {
                    setGuides([]);
                }

                if (tool === 'wall' && currentWall) {
                    let targetX = x;
                    let targetY = y;

                    // Shift í‚¤ë¥¼ ëˆ„ë¥´ë©´ ìˆ˜ì§/ìˆ˜í‰ ê³ ì •
                    if (e.shiftKey) {
                        const dx = Math.abs(x - currentWall.start.x);
                        const dy = Math.abs(y - currentWall.start.y);
                        if (dx > dy) {
                            targetY = currentWall.start.y;
                        } else {
                            targetX = currentWall.start.x;
                        }
                    }
                    setCurrentWall(prev => ({ ...prev, end: { x: targetX, y: targetY } }));
                } else if (tool === 'room' && currentRoom.length > 0) {
                    const start = currentRoom[0];
                    const end = { x, y };
                    const newPoints = [
                        start,
                        { x: end.x, y: start.y },
                        end,
                        { x: start.x, y: end.y }
                    ];
                    setCurrentRoom(newPoints);
                } else if (tool === 'door' || tool === 'window' || tool === 'balcony') {
                    let minDist = 20 / scale;
                    let nearest = null;

                    walls.forEach((wall, idx) => {
                        const proj = projectPointOnLine({ x: worldPos.x, y: worldPos.y }, wall.start, wall.end);
                        const d = distance({ x: worldPos.x, y: worldPos.y }, proj);
                        if (d < minDist) {
                            minDist = d;
                            nearest = { wall, idx, t: proj.t };
                        }
                    });

                    if (nearest) {
                        setPreviewOpening({
                            type: tool,
                            wallIndex: nearest.idx,
                            t: nearest.t,
                            width: tool === 'door' ? DOOR_WIDTH : (tool === 'balcony' ? BALCONY_WIDTH : WINDOW_WIDTH),
                            height: tool === 'door' ? DOOR_HEIGHT : (tool === 'balcony' ? BALCONY_HEIGHT : WINDOW_HEIGHT)
                        });
                    } else {
                        setPreviewOpening(null);
                    }
                } else if (FURNITURE_TEMPLATES[tool]) {
                    setPreviewFurniture(prev => ({
                        type: tool,
                        x,
                        y,
                        rotation: prev ? prev.rotation : 0
                    }));
                } else if (tool === 'select' && isDraggingFurniture && selectedFurnitureId) {
                    // ê°€êµ¬ ì´ë™ ì¤‘ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
                    setPreviewFurniture({
                        ...furniture.find(f => f.id === selectedFurnitureId),
                        x, y
                    });
                }
            };

            const handleMouseUp = () => {
                if (mode !== '2D') return;

                if (isPanning) {
                    setIsPanning(false);
                    return;
                }

                if (tool === 'wall' && currentWall) {
                    if (currentWall.start.x !== currentWall.end.x || currentWall.start.y !== currentWall.end.y) {
                        pushState({
                            ...state,
                            walls: [...walls, currentWall]
                        });
                    }
                    setCurrentWall(null);
                } else if (tool === 'room' && currentRoom.length > 0) {
                    if (currentRoom[0].x !== currentRoom[2].x || currentRoom[0].y !== currentRoom[2].y) {
                        pushState({
                            ...state,
                            rooms: [...rooms, { points: currentRoom }]
                        });
                    }
                    setCurrentRoom([]);
                } else if (tool === 'select' && isDraggingFurniture && selectedFurnitureId && previewFurniture) {
                    // ë“œë˜ê·¸ ì¢…ë£Œ: ë³€ê²½ëœ ìœ„ì¹˜ ë° íšŒì „ ì €ì¥
                    const updatedFurniture = furniture.map(f =>
                        f.id === selectedFurnitureId ? { ...f, x: previewFurniture.x, y: previewFurniture.y, rotation: previewFurniture.rotation } : f
                    );
                    pushState({
                        ...state,
                        furniture: updatedFurniture
                    });
                    setIsDraggingFurniture(false);
                    setPreviewFurniture(null);
                }
            };

            const handleDoubleClick = () => { };

            const clearAll = () => {
                if (confirm("ì •ë§ ëª¨ë‘ ì§€ìš°ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                    reset({ walls: [], rooms: [], openings: [], furniture: [] });
                    setCurrentWall(null);
                    setCurrentRoom([]);
                    setPreviewOpening(null);
                    setPreviewFurniture(null);
                    setScale(1);
                    setPan({ x: 0, y: 0 });
                }
            };

            return (
                <div className="flex flex-col h-screen relative" onContextMenu={(e) => e.preventDefault()}>
                    <Toolbar
                        tool={tool}
                        setTool={setTool}
                        undo={undo}
                        redo={redo}
                        canUndo={canUndo}
                        canRedo={canRedo}
                        clearAll={clearAll}
                        mode={mode}
                        setMode={setMode}
                        handleFileDownload={handleFileDownload}
                        handleFileUpload={handleFileUpload}
                    />

                    <div className="flex-1 relative overflow-hidden">
                        {mode === '2D' ? (
                            <div className="w-full h-full bg-white cursor-crosshair">
                                <canvas
                                    ref={canvasRef}
                                    onMouseDown={handleMouseDown}
                                    onMouseMove={handleMouseMove}
                                    onMouseUp={handleMouseUp}
                                    onDoubleClick={handleDoubleClick}
                                    onWheel={handleWheel}
                                    className="block"
                                />
                                <div className="absolute top-6 left-6 bg-white/90 backdrop-blur-md p-4 rounded-2xl shadow-lg border border-white/50 max-w-xs transition-all duration-300 pointer-events-none z-20">
                                    <div className="flex items-center space-x-2 mb-2">
                                        <span className="text-2xl">{TOOLS.find(t => t.id === tool)?.icon || FURNITURE_TOOLS.find(t => t.id === tool)?.icon || 'ğŸ‘†'}</span>
                                        <h3 className="font-bold text-gray-800 text-sm">
                                            {TOOLS.find(t => t.id === tool)?.label || FURNITURE_TOOLS.find(t => t.id === tool)?.label || 'ì„ íƒ ëª¨ë“œ'}
                                        </h3>
                                    </div>
                                    <p className="text-xs text-gray-600 leading-relaxed">
                                        {tool === 'select' && "ê°ì²´ë¥¼ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ê±°ë‚˜ ë“œë˜ê·¸í•˜ì—¬ ì´ë™í•˜ì„¸ìš”."}
                                        {tool === 'wall' && "ë§ˆìš°ìŠ¤ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ë²½ì„ ê·¸ë¦¬ì„¸ìš”. Shiftë¥¼ ëˆ„ë¥´ë©´ ìˆ˜ì§/ìˆ˜í‰ìœ¼ë¡œ ê³ ì •ë©ë‹ˆë‹¤."}
                                        {tool === 'room' && "ë“œë˜ê·¸í•˜ì—¬ ì‚¬ê°í˜• ë°©ì„ ë§Œë“œì„¸ìš”."}
                                        {(tool === 'door' || tool === 'window' || tool === 'balcony') && "ë²½ ìœ„ì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë ¤ ë°°ì¹˜í•˜ì„¸ìš”."}
                                        {FURNITURE_TEMPLATES[tool] && "ì›í•˜ëŠ” ìœ„ì¹˜ì— í´ë¦­í•˜ì—¬ ë°°ì¹˜í•˜ì„¸ìš”."}
                                    </p>
                                    <div className="mt-3 pt-3 border-t border-gray-100 grid grid-cols-2 gap-2 text-[10px] text-gray-500">
                                        <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">ğŸ–±ï¸</span> ì´ë™/ì¤Œ</div>
                                        {FURNITURE_TEMPLATES[tool] && <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">R</span> íšŒì „</div>}
                                        <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">âŒ«</span> ì‚­ì œ</div>
                                        <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">Esc</span> ì·¨ì†Œ</div>
                                    </div>
                                </div>
                            </div>
                        ) : (
                            <Viewer3D walls={walls} rooms={rooms} openings={openings} furniture={furniture} />
                        )}
                        <HelpButton />
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
        // v1.1
    </script>
</body>

</html>