<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Floor Planner</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f3f4f6;
        }

        canvas {
            display: block;
        }

        .canvas-container {
            cursor: crosshair;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.05);
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;
        const { OrbitControls, PointerLockControls } = THREE;

        // ÏÑ§Ï†ï Í∞í
        const GRID_SIZE = 1; // 1cm Îã®ÏúÑ Ïù¥Îèô (Ï†ïÎ∞ÄÌï®)
        const VISUAL_GRID_SIZE = 5; // 5cm Í≤©Ïûê ÌëúÏãú
        const WALL_THICKNESS = 15; // 15cm Î≤Ω ÎëêÍªò
        const WALL_HEIGHT = 240; // 2.4m Î≤Ω ÎÜíÏù¥
        const DOOR_WIDTH = 90; // 90cm Î¨∏ Ìè≠
        const DOOR_HEIGHT = 210; // 2.1m Î¨∏ ÎÜíÏù¥
        const WINDOW_WIDTH = 120; // 1.2m Ï∞ΩÎ¨∏ Ìè≠
        const WINDOW_HEIGHT = 120; // 1.2m Ï∞ΩÎ¨∏ ÎÜíÏù¥
        const WINDOW_SILL = 90; // Ï∞ΩÎ¨∏ Î∞îÎã•ÏóêÏÑú Îñ®Ïñ¥ÏßÑ ÎÜíÏù¥ (90cm)
        const BALCONY_WIDTH = 240; // 2.4m Î∞úÏΩîÎãà Ï∞Ω
        const BALCONY_HEIGHT = 210; // 2.1m Î∞úÏΩîÎãà ÎÜíÏù¥

        const HEIGHT_MALE = 180;
        const HEIGHT_FEMALE = 160;

        const TOOLS = [
            { id: 'select', icon: 'üëÜ', label: 'ÏÑ†ÌÉù' },
            { id: 'wall', icon: 'üß±', label: 'Î≤Ω' },
            { id: 'room', icon: '‚¨õ', label: 'Î∞©(Î∞îÎã•)' },
            { id: 'door', icon: 'üö™', label: 'Î¨∏' },
            { id: 'window', icon: 'ü™ü', label: 'Ï∞ΩÎ¨∏' },
            { id: 'balcony', icon: 'ü™üü™ü', label: 'Î∞úÏΩîÎãà' },
        ];

        const FURNITURE_TOOLS = [
            { id: 'desk', icon: 'ü™ë', label: 'Ï±ÖÏÉÅ' },
            { id: 'sofa_2p', icon: 'üõãÔ∏è', label: 'ÏÜåÌåå(2)' },
            { id: 'sofa_3p', icon: 'üõãÔ∏è', label: 'ÏÜåÌåå(3)' },
            { id: 'bed_single', icon: 'üõèÔ∏è', label: 'Ïπ®ÎåÄ(S)' },
            { id: 'bed_queen', icon: 'üõèÔ∏è', label: 'Ïπ®ÎåÄ(Q)' },
            { id: 'bed_king', icon: 'üõèÔ∏è', label: 'Ïπ®ÎåÄ(K)' },
            { id: 'bookshelf_160', icon: 'üìö', label: 'Ï±ÖÏû•(160)' },
            { id: 'bookshelf_100', icon: 'üìö', label: 'Ï±ÖÏû•(100)' },
            { id: 'fridge_double', icon: 'üßä', label: 'ÎÉâÏû•Í≥†(Ïñë)' },
            { id: 'fridge_single', icon: '‚ùÑÔ∏è', label: 'ÎÉâÏû•Í≥†(Îã®)' },
        ];

        const FURNITURE_TEMPLATES = {
            'desk': { label: 'Ï±ÖÏÉÅ', width: 160, depth: 80, height: 75, color: 0x8b4513 },
            'sofa_2p': { label: 'ÏÜåÌåå 2Ïù∏', width: 160, depth: 80, height: 85, color: 0x9ca3af },
            'sofa_3p': { label: 'ÏÜåÌåå 3Ïù∏', width: 210, depth: 80, height: 85, color: 0x9ca3af },
            'bed_single': { label: 'Ïπ®ÎåÄ S', width: 100, depth: 200, height: 50, color: 0xffffff },
            'bed_queen': { label: 'Ïπ®ÎåÄ Q', width: 150, depth: 200, height: 50, color: 0xffffff },
            'bed_king': { label: 'Ïπ®ÎåÄ K', width: 180, depth: 200, height: 50, color: 0xffffff },
            'bookshelf_160': { label: 'Ï±ÖÏû• 160', width: 160, depth: 30, height: 200, color: 0x8b4513 },
            'bookshelf_100': { label: 'Ï±ÖÏû• 100', width: 100, depth: 30, height: 200, color: 0x8b4513 },
            'fridge_double': { label: 'ÎÉâÏû•Í≥†(ÏñëÎ¨∏)', width: 95, depth: 90, height: 185, color: 0xe5e7eb },
            'fridge_single': { label: 'ÎÉâÏû•Í≥†(Îã®Î¨∏)', width: 60, depth: 70, height: 185, color: 0xe5e7eb },
        };

        // Ïú†Ìã∏Î¶¨Ìã∞
        const snapToGrid = (val) => Math.round(val / GRID_SIZE) * GRID_SIZE;

        const distance = (p1, p2) => Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

        // Ï†êÏù¥ ÏÑ†Î∂Ñ ÏúÑÏóê ÏûàÎäîÏßÄ ÌôïÏù∏ (Ìà¨ÏòÅ)
        const projectPointOnLine = (point, start, end) => {
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const len2 = dx * dx + dy * dy;
            if (len2 === 0) return start;

            let t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / len2;
            t = Math.max(0, Math.min(1, t));

            return {
                x: start.x + t * dx,
                y: start.y + t * dy,
                t: t // ÎπÑÏú® (0~1)
            };
        };

        // --- ÌûàÏä§ÌÜ†Î¶¨ Í¥ÄÎ¶¨ ÌõÖ ---
        const useHistory = (initialState) => {
            const [history, setHistory] = useState([initialState]);
            const [currentIndex, setCurrentIndex] = useState(0);

            // ÏÉÅÌÉú Î≥ÄÍ≤Ω (ÏÉàÎ°úÏö¥ Í∏∞Î°ù Ï∂îÍ∞Ä)
            const pushState = useCallback((newState) => {
                setHistory(prevHistory => {
                    const upToCurrent = prevHistory.slice(0, currentIndex + 1);
                    return [...upToCurrent, newState];
                });
                setCurrentIndex(prev => prev + 1);
            }, [currentIndex]);

            // Ïã§Ìñâ Ï∑®ÏÜå
            const undo = useCallback(() => {
                setCurrentIndex(prev => Math.max(0, prev - 1));
            }, []);

            // Îã§Ïãú Ïã§Ìñâ
            const redo = useCallback(() => {
                setHistory(prevHistory => {
                    setCurrentIndex(prev => Math.min(prevHistory.length - 1, prev + 1));
                    return prevHistory;
                });
            }, []);

            // Ï¥àÍ∏∞Ìôî
            const reset = useCallback((newState) => {
                setHistory([newState]);
                setCurrentIndex(0);
            }, []);

            return {
                state: history[currentIndex],
                pushState,
                undo,
                redo,
                reset,
                canUndo: currentIndex > 0,
                canRedo: currentIndex < history.length - 1
            };
        };

        // ÌÖçÏä§Ï≤ò ÏÉùÏÑ± Ïú†Ìã∏Î¶¨Ìã∞
        const createFloorTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Î≤†Ïù¥Ïä§ Ïª¨Îü¨
            ctx.fillStyle = '#e5d0b1';
            ctx.fillRect(0, 0, 512, 512);

            // ÎÇòÎ¨¥ Í≤∞ Î¨¥Îä¨
            ctx.fillStyle = '#d4b895';
            for (let i = 0; i < 20; i++) {
                const y = i * (512 / 20);
                ctx.fillRect(0, y, 512, 2); // Ï§ÑÎàà

                // ÎÇòÏù¥ÌÖå ÎäêÎÇå
                for (let j = 0; j < 50; j++) {
                    ctx.globalAlpha = 0.1;
                    ctx.fillStyle = '#8b5a2b';
                    const x = Math.random() * 512;
                    const w = Math.random() * 100;
                    ctx.fillRect(x, y + 2, w, (512 / 20) - 4);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        };

        const createWallTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#f3f4f6';
            ctx.fillRect(0, 0, 512, 512);

            // ÎÖ∏Ïù¥Ï¶à
            for (let i = 0; i < 5000; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#e5e7eb';
                ctx.globalAlpha = 0.5;
                ctx.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 1);
            return texture;
        };

        // --- 3D Î∑∞Ïñ¥ Ïª¥Ìè¨ÎÑåÌä∏ ---
        const Viewer3D = ({ walls, rooms, openings, furniture = [] }) => {
            const mountRef = useRef(null);
            const [isFPV, setIsFPV] = useState(false);
            const [gender, setGender] = useState('male'); // 'male' | 'female'
            const [isLocked, setIsLocked] = useState(false);

            // Refs for animation loop access
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const controlsRef = useRef(null);
            const fpvControlsRef = useRef(null);
            const requestRef = useRef(null);

            // Movement state
            const moveState = useRef({
                forward: false,
                backward: false,
                left: false,
                right: false,
                velocity: new THREE.Vector3(),
                direction: new THREE.Vector3()
            });

            // useMemoÎ°ú ÌÖçÏä§Ï≤ò Î∞è Ïû¨Ïßà Ï∫êÏã±
            const floorTexture = useMemo(() => createFloorTexture(), []);
            const wallTexture = useMemo(() => createWallTexture(), []);

            const floorMaterial = useMemo(() => new THREE.MeshStandardMaterial({
                map: floorTexture,
                roughness: 0.8,
                metalness: 0.1,
                side: THREE.DoubleSide
            }), [floorTexture]);

            const wallMaterial = useMemo(() => new THREE.MeshStandardMaterial({
                map: wallTexture,
                roughness: 0.9,
                color: 0xffffff
            }), [wallTexture]);

            // Ï∂©Îèå Í∞êÏßÄ Ìï®Ïàò
            const checkCollision = (x, z) => {
                const PLAYER_RADIUS = 30; // 30cm Î™∏ÌÜµ Î∞òÏßÄÎ¶Ñ
                const THRESHOLD = WALL_THICKNESS / 2 + PLAYER_RADIUS;

                // Ïò§ÌîÑÏÖã (Ï§ëÏïô Ï†ïÎ†¨)
                const offsetX = -window.innerWidth / 2;
                const offsetZ = -window.innerHeight / 2;

                const px = x - offsetX;
                const pz = z - offsetZ;

                for (let i = 0; i < walls.length; i++) {
                    const wall = walls[i];

                    const proj = projectPointOnLine({ x: px, y: pz }, wall.start, wall.end);
                    const dist = distance({ x: px, y: pz }, proj);

                    if (dist < THRESHOLD) {
                        // Î≤ΩÍ≥º Ï∂©ÎèåÌñàÏúºÎÇò, Î¨∏(Ïò§ÌîÑÎãù)Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
                        const wallOpenings = openings.filter(o => o.wallIndex === i);

                        // Ìï¥Îãπ Î≤ΩÏùò Ïò§ÌîÑÎãùÎì§ÏùÑ ÌôïÏù∏
                        const dx = wall.end.x - wall.start.x;
                        const dy = wall.end.y - wall.start.y;
                        const len = Math.sqrt(dx * dx + dy * dy);

                        // Ìà¨ÏòÅÎêú ÏßÄÏ†êÏùò ÎπÑÏú®(t)Ïù¥ Ïò§ÌîÑÎãù Íµ¨Í∞Ñ ÎÇ¥Ïóê ÏûàÎäîÏßÄ ÌôïÏù∏
                        const isPassingThroughDoor = wallOpenings.some(op => {
                            if (op.type !== 'door' && op.type !== 'balcony') return false; // Ï∞ΩÎ¨∏ÏùÄ ÌÜµÍ≥º Î∂àÍ∞Ä

                            const opWidth = op.type === 'door' ? DOOR_WIDTH : BALCONY_WIDTH;
                            const opPos = op.t * len;
                            const start = opPos - opWidth / 2;
                            const end = opPos + opWidth / 2;

                            const projPos = proj.t * len;

                            // ÌîåÎ†àÏù¥Ïñ¥Ïùò Î∞òÏßÄÎ¶ÑÏùÑ Í≥†Î†§ÌïòÏó¨ Ïò§ÌîÑÎãù Î≤îÏúÑ ÎÇ¥Ïù∏ÏßÄ ÌôïÏù∏ (Ï°∞Í∏à Ïó¨Ïú† ÏûàÍ≤å)
                            return projPos >= (start + 10) && projPos <= (end - 10);
                        });

                        if (isPassingThroughDoor) return false; // Î¨∏Ïù¥Î©¥ ÌÜµÍ≥º Í∞ÄÎä•

                        return true; // Î¨∏Ïù¥ ÏïÑÎãàÎ©¥ Ï∂©Îèå
                    }
                }
                return false;
            };

            useEffect(() => {
                if (!mountRef.current) return;

                // Scene Setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xe0f2fe); // ÌïòÎäòÏÉâ Î∞∞Í≤Ω
                scene.fog = new THREE.Fog(0xe0f2fe, 500, 3000); // ÏïàÍ∞ú Ìö®Í≥ºÎ°ú ÍπäÏù¥Í∞ê Ï∂îÍ∞Ä
                sceneRef.current = scene;

                const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 5000);
                cameraRef.current = camera;

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight - 80);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Î∂ÄÎìúÎü¨Ïö¥ Í∑∏Î¶ºÏûê
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);

                const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
                hemiLight.position.set(0, 200, 0);
                scene.add(hemiLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(500, 1500, 1000);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.camera.near = 0.5;
                dirLight.shadow.camera.far = 5000;
                dirLight.shadow.camera.left = -1500;
                dirLight.shadow.camera.right = 1500;
                dirLight.shadow.camera.top = 1500;
                dirLight.shadow.camera.bottom = -1500;
                dirLight.shadow.bias = -0.0001;
                scene.add(dirLight);



                // Ground (Ïô∏Î∂Ä Î∞îÎã•)
                const planeGeometry = new THREE.PlaneGeometry(10000, 10000);
                const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xf9fafb, roughness: 1 });
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = -Math.PI / 2;
                plane.position.y = -1;
                plane.receiveShadow = true;
                scene.add(plane);

                const gridHelper = new THREE.GridHelper(5000, 500, 0xcbd5e1, 0xe2e8f0);
                scene.add(gridHelper);

                // Offset
                const offsetX = -window.innerWidth / 2;
                const offsetZ = -window.innerHeight / 2;

                // Build Scene Objects
                rooms.forEach(room => {
                    if (room.points.length < 3) return;
                    const shape = new THREE.Shape();
                    shape.moveTo(room.points[0].x + offsetX, room.points[0].y + offsetZ);
                    for (let i = 1; i < room.points.length; i++) {
                        shape.lineTo(room.points[i].x + offsetX, room.points[i].y + offsetZ);
                    }
                    shape.lineTo(room.points[0].x + offsetX, room.points[0].y + offsetZ);
                    const geometry = new THREE.ShapeGeometry(shape);

                    // Î∞© Î∞îÎã•Ïóê ÌÖçÏä§Ï≤ò Ï†ÅÏö© (Ï∫êÏã±Îêú Ïû¨Ïßà ÏÇ¨Ïö©)
                    const material = floorMaterial;

                    // UV Îß§Ìïë Ï°∞Ï†ï (ÌÖçÏä§Ï≤ò Ïä§ÏºÄÏùº)
                    const posAttribute = geometry.attributes.position;
                    const uvAttribute = geometry.attributes.uv;
                    for (let i = 0; i < posAttribute.count; i++) {
                        const x = posAttribute.getX(i);
                        const y = posAttribute.getY(i);
                        uvAttribute.setXY(i, x / 500, y / 500); // 500 Îã®ÏúÑÎ°ú Î∞òÎ≥µ
                    }

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.rotation.x = Math.PI / 2;
                    mesh.position.y = 0.5;
                    mesh.receiveShadow = true;
                    scene.add(mesh);
                });

                walls.forEach((wall, index) => {
                    const wallOpenings = openings.filter(o => o.wallIndex === index);
                    const dx = wall.end.x - wall.start.x;
                    const dy = wall.end.y - wall.start.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);

                    const wallMat = wallMaterial;

                    if (wallOpenings.length === 0) {
                        const geometry = new THREE.BoxGeometry(len, WALL_HEIGHT, WALL_THICKNESS);
                        const mesh = new THREE.Mesh(geometry, wallMat);
                        const cx = (wall.start.x + wall.end.x) / 2;
                        const cz = (wall.start.y + wall.end.y) / 2;
                        mesh.position.set(cx + offsetX, WALL_HEIGHT / 2, cz + offsetZ);
                        mesh.rotation.y = -angle;
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        scene.add(mesh);
                    } else {
                        wallOpenings.sort((a, b) => a.t - b.t);
                        let currentPos = 0;
                        const wallGroup = new THREE.Group();
                        wallGroup.position.set(wall.start.x + offsetX, 0, wall.start.y + offsetZ);
                        wallGroup.rotation.y = -angle;

                        wallOpenings.forEach(op => {
                            const opPos = op.t * len;
                            const opWidth = op.type === 'door' ? DOOR_WIDTH : (op.type === 'balcony' ? BALCONY_WIDTH : WINDOW_WIDTH);
                            const opHeight = op.type === 'door' ? DOOR_HEIGHT : (op.type === 'balcony' ? BALCONY_HEIGHT : WINDOW_HEIGHT);
                            const opY = (op.type === 'door' || op.type === 'balcony') ? 0 : WINDOW_SILL;
                            const start = opPos - opWidth / 2;
                            const end = opPos + opWidth / 2;

                            if (start > currentPos) {
                                const segLen = start - currentPos;
                                const geom = new THREE.BoxGeometry(segLen, WALL_HEIGHT, WALL_THICKNESS);
                                const mesh = new THREE.Mesh(geom, wallMat);
                                mesh.position.set(currentPos + segLen / 2, WALL_HEIGHT / 2, 0);
                                mesh.castShadow = true;
                                mesh.receiveShadow = true;
                                wallGroup.add(mesh);
                            }

                            const headerHeight = WALL_HEIGHT - (opY + opHeight);
                            if (headerHeight > 0) {
                                const geom = new THREE.BoxGeometry(opWidth, headerHeight, WALL_THICKNESS);
                                const mesh = new THREE.Mesh(geom, wallMat);
                                mesh.position.set(opPos, WALL_HEIGHT - headerHeight / 2, 0);
                                mesh.castShadow = true;
                                mesh.receiveShadow = true;
                                wallGroup.add(mesh);
                            }

                            if (opY > 0) {
                                const geom = new THREE.BoxGeometry(opWidth, opY, WALL_THICKNESS);
                                const mesh = new THREE.Mesh(geom, wallMat);
                                mesh.position.set(opPos, opY / 2, 0);
                                mesh.castShadow = true;
                                mesh.receiveShadow = true;
                                wallGroup.add(mesh);
                            }

                            if (op.type === 'door') {
                                const doorGeom = new THREE.BoxGeometry(opWidth, opHeight, 5);
                                const doorMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.6 });
                                const door = new THREE.Mesh(doorGeom, doorMat);
                                door.position.set(opPos, opHeight / 2, 0);
                                door.rotation.y = Math.PI / 6;
                                door.position.z = -10;
                                door.castShadow = true;
                                wallGroup.add(door);
                            } else if (op.type === 'balcony') {
                                // Î∞úÏΩîÎãà Ï∞Ω (Ïú†Î¶¨)
                                const winGeom = new THREE.BoxGeometry(opWidth, opHeight, 2);
                                const winMat = new THREE.MeshPhysicalMaterial({
                                    color: 0x87ceeb,
                                    transparent: true,
                                    opacity: 0.3,
                                    metalness: 0.1,
                                    roughness: 0,
                                    transmission: 0.9
                                });
                                const win = new THREE.Mesh(winGeom, winMat);
                                win.position.set(opPos, opHeight / 2, 0);
                                wallGroup.add(win);
                            } else {
                                const winGeom = new THREE.BoxGeometry(opWidth, opHeight, 2);
                                const winMat = new THREE.MeshPhysicalMaterial({
                                    color: 0x87ceeb,
                                    transparent: true,
                                    opacity: 0.5,
                                    metalness: 0.1,
                                    roughness: 0,
                                    transmission: 0.9
                                });
                                const win = new THREE.Mesh(winGeom, winMat);
                                win.position.set(opPos, opY + opHeight / 2, 0);
                                wallGroup.add(win);
                            }
                            currentPos = end;
                        });

                        if (currentPos < len) {
                            const segLen = len - currentPos;
                            const geom = new THREE.BoxGeometry(segLen, WALL_HEIGHT, WALL_THICKNESS);
                            const mesh = new THREE.Mesh(geom, wallMat);
                            mesh.position.set(currentPos + segLen / 2, WALL_HEIGHT / 2, 0);
                            mesh.castShadow = true;
                            mesh.receiveShadow = true;
                            wallGroup.add(mesh);
                        }
                        scene.add(wallGroup);
                    }
                });

                furniture.forEach(item => {
                    const template = FURNITURE_TEMPLATES[item.type];
                    if (!template) return;
                    const group = new THREE.Group();
                    group.position.set(item.x + offsetX, 0, item.y + offsetZ);
                    group.rotation.y = -item.rotation;
                    const { width, depth, height, color } = template;

                    // Í∞ÄÍµ¨ Ïû¨Ïßà (Standard Material)
                    const furnitureMat = new THREE.MeshStandardMaterial({ color, roughness: 0.7 });

                    if (item.type.includes('bed')) {
                        const frameGeom = new THREE.BoxGeometry(width, 30, depth);
                        const frameMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.8 });
                        const frame = new THREE.Mesh(frameGeom, frameMat);
                        frame.position.y = 15;
                        frame.castShadow = true;
                        group.add(frame);

                        const matGeom = new THREE.BoxGeometry(width - 10, 20, depth - 10);
                        const matMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 });
                        const mat = new THREE.Mesh(matGeom, matMat);
                        mat.position.y = 30 + 10;
                        mat.castShadow = true;
                        group.add(mat);

                        const pillowGeom = new THREE.BoxGeometry(width - 20, 10, 30);
                        const pillowMat = new THREE.MeshStandardMaterial({ color: 0xe5e7eb, roughness: 1 });
                        const pillow = new THREE.Mesh(pillowGeom, pillowMat);
                        pillow.position.set(0, 55, -depth / 2 + 25);
                        pillow.castShadow = true;
                        group.add(pillow);

                        const headGeom = new THREE.BoxGeometry(width, 100, 10);
                        const headMat = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.6 });
                        const head = new THREE.Mesh(headGeom, headMat);
                        head.position.set(0, 50, -depth / 2 + 5);
                        head.castShadow = true;
                        group.add(head);
                    } else if (item.type.includes('sofa')) {
                        const seatHeight = 40;
                        const seatGeom = new THREE.BoxGeometry(width, seatHeight, depth - 20);
                        const seatMat = new THREE.MeshStandardMaterial({ color, roughness: 1 }); // Ìå®Î∏åÎ¶≠ ÎäêÎÇå
                        const seat = new THREE.Mesh(seatGeom, seatMat);
                        seat.position.set(0, seatHeight / 2, 10);
                        seat.castShadow = true;
                        group.add(seat);

                        const backGeom = new THREE.BoxGeometry(width, height, 20);
                        const back = new THREE.Mesh(backGeom, seatMat);
                        back.position.set(0, height / 2, -depth / 2 + 10);
                        back.castShadow = true;
                        group.add(back);

                        const armGeom = new THREE.BoxGeometry(15, 60, depth);
                        const armLeft = new THREE.Mesh(armGeom, seatMat);
                        armLeft.position.set(-width / 2 + 7.5, 30, 0);
                        group.add(armLeft);

                        const armRight = new THREE.Mesh(armGeom, seatMat);
                        armRight.position.set(width / 2 - 7.5, 30, 0);
                        group.add(armRight);
                    } else if (item.type === 'desk') {
                        const topGeom = new THREE.BoxGeometry(width, 5, depth);
                        const topMat = new THREE.MeshStandardMaterial({ color, roughness: 0.5, metalness: 0.1 });
                        const top = new THREE.Mesh(topGeom, topMat);
                        top.position.y = height - 2.5;
                        top.castShadow = true;
                        group.add(top);

                        const legGeom = new THREE.BoxGeometry(5, height - 5, 5);
                        const legMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.2, metalness: 0.8 });
                        [{ x: -width / 2 + 10, z: -depth / 2 + 10 }, { x: width / 2 - 10, z: -depth / 2 + 10 },
                        { x: -width / 2 + 10, z: depth / 2 - 10 }, { x: width / 2 - 10, z: depth / 2 - 10 }]
                            .forEach(pos => {
                                const leg = new THREE.Mesh(legGeom, legMat);
                                leg.position.set(pos.x, (height - 5) / 2, pos.z);
                                leg.castShadow = true;
                                group.add(leg);
                            });
                    } else if (item.type.includes('bookshelf')) {
                        const thickness = 2;
                        const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });

                        // Back
                        const backGeom = new THREE.BoxGeometry(width, height, thickness);
                        const back = new THREE.Mesh(backGeom, mat);
                        back.position.set(0, height / 2, -depth / 2 + thickness / 2);
                        back.castShadow = true;
                        group.add(back);

                        // Sides
                        const sideGeom = new THREE.BoxGeometry(thickness, height, depth);
                        const left = new THREE.Mesh(sideGeom, mat);
                        left.position.set(-width / 2 + thickness / 2, height / 2, 0);
                        left.castShadow = true;
                        group.add(left);

                        const right = new THREE.Mesh(sideGeom, mat);
                        right.position.set(width / 2 - thickness / 2, height / 2, 0);
                        right.castShadow = true;
                        group.add(right);

                        // Shelves
                        const shelfCount = 6;
                        const shelfGeom = new THREE.BoxGeometry(width - thickness * 2, thickness, depth - thickness);
                        for (let i = 0; i < shelfCount; i++) {
                            const shelf = new THREE.Mesh(shelfGeom, mat);
                            const posY = (height - thickness) * (i / (shelfCount - 1)) + thickness / 2;
                            shelf.position.set(0, posY, thickness / 2);
                            shelf.castShadow = true;
                            group.add(shelf);
                        }
                    } else if (item.type.includes('fridge')) {
                        // Body
                        const bodyGeom = new THREE.BoxGeometry(width, height, depth - 5);
                        const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.2, metalness: 0.1 });
                        const body = new THREE.Mesh(bodyGeom, bodyMat);
                        body.position.set(0, height / 2, -2.5);
                        body.castShadow = true;
                        group.add(body);

                        // Doors
                        const doorDepth = 5;
                        const doorGap = 0.5;

                        if (item.type === 'fridge_double') {
                            const doorWidth = (width - doorGap) / 2;
                            const doorGeom = new THREE.BoxGeometry(doorWidth, height, doorDepth);

                            const leftDoor = new THREE.Mesh(doorGeom, bodyMat);
                            leftDoor.position.set(-width / 4 - doorGap / 4, height / 2, depth / 2 - doorDepth / 2);
                            leftDoor.castShadow = true;
                            group.add(leftDoor);

                            const rightDoor = new THREE.Mesh(doorGeom, bodyMat);
                            rightDoor.position.set(width / 4 + doorGap / 4, height / 2, depth / 2 - doorDepth / 2);
                            rightDoor.castShadow = true;
                            group.add(rightDoor);

                            // Handles
                            const handleGeom = new THREE.BoxGeometry(2, 40, 2);
                            const handleMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.1, metalness: 0.8 });

                            const leftHandle = new THREE.Mesh(handleGeom, handleMat);
                            leftHandle.position.set(-5, height / 2, depth / 2 + 1);
                            group.add(leftHandle);

                            const rightHandle = new THREE.Mesh(handleGeom, handleMat);
                            rightHandle.position.set(5, height / 2, depth / 2 + 1);
                            group.add(rightHandle);
                        } else {
                            const doorGeom = new THREE.BoxGeometry(width, height, doorDepth);
                            const door = new THREE.Mesh(doorGeom, bodyMat);
                            door.position.set(0, height / 2, depth / 2 - doorDepth / 2);
                            door.castShadow = true;
                            group.add(door);

                            // Handle
                            const handleGeom = new THREE.BoxGeometry(2, 40, 2);
                            const handleMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.1, metalness: 0.8 });
                            const handle = new THREE.Mesh(handleGeom, handleMat);
                            handle.position.set(-width / 2 + 10, height / 2, depth / 2 + 1);
                            group.add(handle);
                        }
                    }
                    scene.add(group);
                });

                // Controls Setup
                const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
                orbitControls.enableDamping = true;
                controlsRef.current = orbitControls;

                const fpvControls = new THREE.PointerLockControls(camera, renderer.domElement);
                fpvControls.addEventListener('lock', () => setIsLocked(true));
                fpvControls.addEventListener('unlock', () => setIsLocked(false));
                fpvControlsRef.current = fpvControls;

                // Initial Camera Position (Orbit)
                camera.position.set(500, 800, 800);
                camera.lookAt(0, 0, 0);

                let prevTime = performance.now();

                const animate = () => {
                    requestRef.current = requestAnimationFrame(animate);

                    const time = performance.now();
                    const delta = (time - prevTime) / 1000;
                    prevTime = time;

                    if (fpvControls.isLocked) {
                        const velocity = moveState.current.velocity;
                        const direction = moveState.current.direction;

                        velocity.x -= velocity.x * 10.0 * delta;
                        velocity.z -= velocity.z * 10.0 * delta;

                        direction.z = Number(moveState.current.forward) - Number(moveState.current.backward);
                        direction.x = Number(moveState.current.right) - Number(moveState.current.left);
                        direction.normalize();

                        if (moveState.current.forward || moveState.current.backward) velocity.z -= direction.z * 4000.0 * delta;
                        if (moveState.current.left || moveState.current.right) velocity.x -= direction.x * 4000.0 * delta;

                        // --- Ï∂©Îèå Ï≤òÎ¶¨ Í∞úÏÑ† (Move and Revert Î∞©Ïãù) ---

                        // 1. XÏ∂ï Ïù¥Îèô (Ï¢åÏö∞)
                        const oldX = camera.position.x;
                        const oldZ = camera.position.z;

                        fpvControls.moveRight(-velocity.x * delta);

                        if (checkCollision(camera.position.x, camera.position.z)) {
                            camera.position.x = oldX;
                            camera.position.z = oldZ;
                            velocity.x = 0;
                        }

                        // 2. ZÏ∂ï Ïù¥Îèô (Ï†ÑÌõÑ)
                        const currX = camera.position.x;
                        const currZ = camera.position.z;

                        fpvControls.moveForward(-velocity.z * delta);

                        if (checkCollision(camera.position.x, camera.position.z)) {
                            camera.position.x = currX;
                            camera.position.z = currZ;
                            velocity.z = 0;
                        }

                        // 3. ÎÜíÏù¥ Í≥†Ï†ï (ÎπÑÌñâ/ÎïÖÌååÍ∏∞ Î∞©ÏßÄ)
                        const h = gender === 'male' ? HEIGHT_MALE : HEIGHT_FEMALE;
                        camera.position.y = h;
                    } else {
                        orbitControls.update();
                    }

                    renderer.render(scene, camera);
                };
                animate();

                // Key handlers for movement
                const onKeyDown = (event) => {
                    switch (event.code) {
                        case 'ArrowUp': case 'KeyW': moveState.current.forward = true; break;
                        case 'ArrowLeft': case 'KeyA': moveState.current.left = true; break;
                        case 'ArrowDown': case 'KeyS': moveState.current.backward = true; break;
                        case 'ArrowRight': case 'KeyD': moveState.current.right = true; break;
                    }
                };
                const onKeyUp = (event) => {
                    switch (event.code) {
                        case 'ArrowUp': case 'KeyW': moveState.current.forward = false; break;
                        case 'ArrowLeft': case 'KeyA': moveState.current.left = false; break;
                        case 'ArrowDown': case 'KeyS': moveState.current.backward = false; break;
                        case 'ArrowRight': case 'KeyD': moveState.current.right = false; break;
                    }
                };

                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);

                return () => {
                    if (mountRef.current) mountRef.current.innerHTML = '';
                    renderer.dispose();
                    cancelAnimationFrame(requestRef.current);
                    document.removeEventListener('keydown', onKeyDown);
                    document.removeEventListener('keyup', onKeyUp);
                };
            }, [walls, rooms, openings, furniture]);

            // Mode Switching Effect
            useEffect(() => {
                if (!cameraRef.current || !controlsRef.current) return;

                if (isFPV) {
                    controlsRef.current.enabled = false;
                    // Set initial FPV position (center of room or current position if reasonable)
                    // Just reset to a safe height
                    const h = gender === 'male' ? HEIGHT_MALE : HEIGHT_FEMALE;
                    cameraRef.current.position.y = h;
                    cameraRef.current.lookAt(cameraRef.current.position.x, h, cameraRef.current.position.z - 100);
                } else {
                    controlsRef.current.enabled = true;
                    if (fpvControlsRef.current) fpvControlsRef.current.unlock();
                    // Reset to bird's eye view
                    cameraRef.current.position.set(500, 800, 800);
                    cameraRef.current.lookAt(0, 0, 0);
                }
            }, [isFPV, gender]);

            const toggleLock = () => {
                if (fpvControlsRef.current) {
                    fpvControlsRef.current.lock();
                }
            };

            return (
                <div ref={mountRef} className="w-full h-full bg-gray-200 relative">
                    <div className="absolute top-4 right-4 z-10 flex flex-col space-y-2">
                        <button
                            onClick={() => setIsFPV(!isFPV)}
                            className={`px-4 py-2 rounded shadow font-bold ${isFPV ? 'bg-green-600 text-white' : 'bg-white text-gray-800'}`}
                        >
                            {isFPV ? 'ü¶Ö 3D Ï°∞Í∞êÎèÑ Î™®Îìú' : 'üö∂ 1Ïù∏Ïπ≠ Í¥ÄÎûå Î™®Îìú'}
                        </button>

                        {isFPV && (
                            <div className="bg-white p-4 rounded shadow-lg flex flex-col space-y-2">
                                <p className="text-sm font-bold text-gray-600 mb-2">ÏÑ§Ï†ï</p>
                                <div className="flex space-x-2 bg-gray-100 p-1 rounded">
                                    <button
                                        onClick={() => setGender('male')}
                                        className={`flex-1 py-1 rounded text-sm ${gender === 'male' ? 'bg-blue-500 text-white' : 'text-gray-600'}`}
                                    >
                                        ÎÇ® (180cm)
                                    </button>
                                    <button
                                        onClick={() => setGender('female')}
                                        className={`flex-1 py-1 rounded text-sm ${gender === 'female' ? 'bg-pink-500 text-white' : 'text-gray-600'}`}
                                    >
                                        Ïó¨ (160cm)
                                    </button>
                                </div>

                                {!isLocked && (
                                    <button
                                        onClick={toggleLock}
                                        className="w-full py-3 bg-blue-600 text-white rounded font-bold hover:bg-blue-700 mt-2"
                                    >
                                        Í¥ÄÎûå ÏãúÏûë (ÌÅ¥Î¶≠)
                                    </button>
                                )}

                                <div className="text-xs text-gray-500 mt-2">
                                    <p>W,A,S,D: Ïù¥Îèô</p>
                                    <p>ÎßàÏö∞Ïä§: ÏãúÏÑ† Ïù¥Îèô</p>
                                    <p>ESC: Ïª§ÏÑú Ïû†Í∏à Ìï¥Ï†ú</p>
                                </div>
                            </div>
                        )}
                    </div>
                    {isFPV && !isLocked && (
                        <div className="absolute inset-0 flex items-center justify-center bg-black/30 z-0 pointer-events-none">
                            <div className="text-white text-2xl font-bold drop-shadow-md">
                                Ïö∞Ï∏° ÏÉÅÎã®Ïùò 'Í¥ÄÎûå ÏãúÏûë'ÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- Ìà¥Î∞î Ïª¥Ìè¨ÎÑåÌä∏ ---
        const Toolbar = ({ tool, setTool, undo, redo, canUndo, canRedo, clearAll, mode, setMode, handleFileDownload, handleFileUpload }) => {

            return (
                <div className="bg-white/90 backdrop-blur-md border-b border-gray-200 p-4 flex justify-between items-center shadow-sm z-10 h-[80px]">
                    <div className="flex items-center space-x-6">
                        <h1 className="text-2xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-indigo-600 mr-4">
                            Floor Planner <span className="text-xs font-medium text-gray-500">Pro</span>
                        </h1>

                        {/* Î©îÏù∏ Ìà¥Î∞î */}
                        <div className="flex bg-gray-100/50 p-1.5 rounded-xl space-x-1 border border-gray-200">
                            {TOOLS.map(t => (
                                <button
                                    key={t.id}
                                    onClick={() => setTool(tool === t.id ? 'select' : t.id)}
                                    className={`px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 flex items-center space-x-2 ${tool === t.id
                                        ? 'bg-white text-blue-600 shadow-md scale-105'
                                        : 'text-gray-600 hover:bg-gray-200/80 hover:text-gray-900'
                                        }`}
                                >
                                    <span>{t.icon}</span>
                                    <span className="hidden lg:inline">{t.label}</span>
                                </button>
                            ))}
                            <div className="w-px h-6 bg-gray-300 mx-2 self-center"></div>
                            {/* Í∞ÄÍµ¨ Ìà¥Î∞î */}
                            {FURNITURE_TOOLS.map(t => (
                                <button
                                    key={t.id}
                                    onClick={() => setTool(tool === t.id ? 'select' : t.id)}
                                    className={`p-2 rounded-lg text-xs font-medium transition-all duration-200 flex flex-col items-center justify-center w-10 h-10 ${tool === t.id
                                        ? 'bg-white text-blue-600 shadow-md scale-105'
                                        : 'text-gray-600 hover:bg-gray-200/80 hover:text-gray-900'
                                        }`}
                                    title={t.label}
                                >
                                    <span className="text-lg leading-none">{t.icon}</span>
                                </button>
                            ))}
                        </div>

                        {/* Undo/Redo */}
                        <div className="flex bg-gray-100/50 p-1.5 rounded-xl space-x-1 border border-gray-200">
                            <button
                                onClick={undo}
                                disabled={!canUndo}
                                className={`p-2 rounded-lg transition-colors ${canUndo ? 'text-gray-700 hover:bg-white hover:shadow-sm' : 'text-gray-300 cursor-not-allowed'}`}
                                title="Ïã§Ìñâ Ï∑®ÏÜå (Ctrl+Z)"
                            >
                                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path></svg>
                            </button>
                            <button
                                onClick={redo}
                                disabled={!canRedo}
                                className={`p-2 rounded-lg transition-colors ${canRedo ? 'text-gray-700 hover:bg-white hover:shadow-sm' : 'text-gray-300 cursor-not-allowed'}`}
                                title="Îã§Ïãú Ïã§Ìñâ (Ctrl+Y)"
                            >
                                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 10h-10a8 8 0 00-8 8v2M21 10l-6 6m6-6l-6-6"></path></svg>
                            </button>
                        </div>
                    </div>

                    <div className="flex items-center space-x-3">
                        <input
                            type="file"
                            id="file-upload"
                            className="hidden"
                            accept=".json"
                            onChange={handleFileUpload}
                        />
                        <div className="flex bg-gray-100/50 p-1 rounded-lg border border-gray-200">
                            <button
                                onClick={() => document.getElementById('file-upload').click()}
                                className="px-3 py-1.5 rounded-md text-sm font-medium text-gray-600 hover:bg-white hover:shadow-sm transition-all"
                                title="JSON ÌååÏùº Î∂àÎü¨Ïò§Í∏∞"
                            >
                                üìÇ Ïó¥Í∏∞
                            </button>
                            <button
                                onClick={handleFileDownload}
                                className="px-3 py-1.5 rounded-md text-sm font-medium text-gray-600 hover:bg-white hover:shadow-sm transition-all"
                                title="JSON ÌååÏùºÎ°ú Ï†ÄÏû•"
                            >
                                üíæ Ï†ÄÏû•
                            </button>
                        </div>

                        <div className="w-px h-8 bg-gray-200 mx-2"></div>

                        <button onClick={clearAll} className="text-red-500 hover:bg-red-50 px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                            Ï¥àÍ∏∞Ìôî
                        </button>
                        <button
                            onClick={() => setMode(mode === '2D' ? '3D' : '2D')}
                            className={`px-6 py-2.5 rounded-xl font-bold shadow-lg transition-all transform hover:-translate-y-0.5 active:translate-y-0 ${mode === '2D'
                                ? 'bg-gradient-to-r from-blue-600 to-indigo-600 text-white hover:shadow-blue-500/30'
                                : 'bg-white text-gray-800 border border-gray-200 hover:bg-gray-50'
                                }`}
                        >
                            {mode === '2D' ? '3DÎ°ú Î≥¥Í∏∞ ‚ú®' : '2D Ìé∏ÏßëÍ∏∞Î°ú ÎèåÏïÑÍ∞ÄÍ∏∞'}
                        </button>
                    </div>
                </div>
            );
        };

        const HelpButton = () => {
            return (
                <div className="absolute bottom-6 right-6 z-50 group">
                    <button className="w-12 h-12 bg-white rounded-full shadow-lg flex items-center justify-center text-gray-600 hover:text-blue-600 hover:scale-110 transition-all border border-gray-200">
                        <span className="text-xl font-bold">?</span>
                    </button>
                    <div className="absolute bottom-16 right-0 w-64 bg-white/90 backdrop-blur-md p-4 rounded-2xl shadow-xl border border-white/50 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none group-hover:pointer-events-auto transform translate-y-2 group-hover:translate-y-0 duration-200">
                        <h4 className="font-bold text-gray-800 mb-3 text-sm">Îã®Ï∂ïÌÇ§ ÏïàÎÇ¥</h4>
                        <div className="space-y-2 text-xs text-gray-600">
                            <div className="flex justify-between"><span>Ïã§Ìñâ Ï∑®ÏÜå</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Ctrl + Z</kbd></div>
                            <div className="flex justify-between"><span>Îã§Ïãú Ïã§Ìñâ</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Ctrl + Y</kbd></div>
                            <div className="flex justify-between"><span>ÌöåÏ†Ñ (Í∞ÄÍµ¨)</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">R</kbd></div>
                            <div className="flex justify-between"><span>ÏÇ≠Ï†ú</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Del</kbd></div>
                            <div className="flex justify-between"><span>Ï∑®ÏÜå</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">Esc</kbd></div>
                            <div className="border-t border-gray-200 my-2 pt-2"></div>
                            <div className="flex justify-between"><span>3D Ïù¥Îèô</span> <kbd className="bg-gray-100 px-2 py-0.5 rounded font-mono">W A S D</kbd></div>
                            <div className="flex justify-between"><span>ÏãúÏÑ† Ïù¥Îèô</span> <span className="text-gray-500">ÎßàÏö∞Ïä§</span></div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Î©îÏù∏ Ïï± Ïª¥Ìè¨ÎÑåÌä∏ ---
        const App = () => {
            const [mode, setMode] = useState('2D');
            const [tool, setTool] = useState('select'); // 'select', 'wall', 'room', 'door', 'window', 'bed_single', 'desk', etc.

            // Undo/RedoÎ•º ÏúÑÌïú ÌÜµÌï© ÏÉÅÌÉú Í¥ÄÎ¶¨
            const { state, pushState, undo, redo, reset, canUndo, canRedo } = useHistory({
                walls: [],
                rooms: [],
                openings: [],
                furniture: []
            });

            const { walls, rooms, openings, furniture } = state;

            // ÏûÑÏãú Í∑∏Î¶¨Í∏∞ ÏÉÅÌÉú (ÌûàÏä§ÌÜ†Î¶¨Ïóê Ï†ÄÏû• Ïïà Ìï®)
            const [currentWall, setCurrentWall] = useState(null);
            const [currentRoom, setCurrentRoom] = useState([]);
            const [previewOpening, setPreviewOpening] = useState(null);
            const [previewFurniture, setPreviewFurniture] = useState(null); // { type, x, y, rotation }
            const [selectedFurnitureId, setSelectedFurnitureId] = useState(null);
            const [isDraggingFurniture, setIsDraggingFurniture] = useState(false);

            // Î∑∞Ìè¨Ìä∏ ÏÉÅÌÉú (Ï§å & Ìå¨)
            const [scale, setScale] = useState(1);
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [isPanning, setIsPanning] = useState(false);
            const [lastMousePos, setLastMousePos] = useState({ x: 0, y: 0 });

            // Ïä§ÎßàÌä∏ Í∞ÄÏù¥Îìú ÏÉÅÌÉú
            const [guides, setGuides] = useState([]); // [{ type: 'x'|'y', pos: number, start: number, end: number }]

            const canvasRef = useRef(null);

            // Îã®Ï∂ïÌÇ§ Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨
            useEffect(() => {
                const handleKeyDown = (e) => {
                    // Ctrl+Z (Undo), Ctrl+Shift+Z or Ctrl+Y (Redo)
                    if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
                        if (e.shiftKey) {
                            e.preventDefault();
                            if (canRedo) redo();
                        } else {
                            e.preventDefault();
                            if (canUndo) undo();
                        }
                    } else if ((e.metaKey || e.ctrlKey) && e.key === 'y') {
                        e.preventDefault();
                        if (canRedo) redo();
                    } else if (e.code === 'KeyR') {
                        // Í∞ÄÍµ¨ ÌöåÏ†Ñ
                        if (previewFurniture) {
                            setPreviewFurniture(prev => ({
                                ...prev,
                                rotation: (prev.rotation + Math.PI / 2) % (Math.PI * 2)
                            }));
                        } else if (selectedFurnitureId) {
                            // ÏÑ†ÌÉùÎêú Í∞ÄÍµ¨ ÌöåÏ†Ñ
                            pushState({
                                ...state,
                                furniture: furniture.map(f =>
                                    f.id === selectedFurnitureId
                                        ? { ...f, rotation: (f.rotation + Math.PI / 2) % (Math.PI * 2) }
                                        : f
                                )
                            });
                        }
                    } else if (e.key === 'Delete' || e.key === 'Backspace') {
                        if (selectedFurnitureId) {
                            pushState({
                                ...state,
                                furniture: furniture.filter(f => f.id !== selectedFurnitureId)
                            });
                            setSelectedFurnitureId(null);
                        }
                    } else if (e.key === 'Escape') {
                        setTool('select');
                        setSelectedFurnitureId(null);
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [undo, redo, canUndo, canRedo, previewFurniture, selectedFurnitureId, furniture, state, pushState]);

            // Ìà¥ Î≥ÄÍ≤Ω Ïãú ÏûÑÏãú ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            useEffect(() => {
                setCurrentWall(null);
                setCurrentRoom([]);
                setPreviewOpening(null);
                setPreviewFurniture(null);
                setSelectedFurnitureId(null);
            }, [tool]);

            // --- Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•/Î°úÎìú (LocalStorage & File) ---

            // 1. ÏûêÎèô Ï†ÄÏû• (Auto Save)
            useEffect(() => {
                const data = { walls, rooms, openings, furniture };
                localStorage.setItem('floorPlanData', JSON.stringify(data));
            }, [walls, rooms, openings, furniture]);

            // 2. Ï¥àÍ∏∞ Î°úÎìú (Auto Load)
            useEffect(() => {
                const savedData = localStorage.getItem('floorPlanData');
                if (savedData) {
                    try {
                        const parsed = JSON.parse(savedData);
                        // Îç∞Ïù¥ÌÑ∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (Í∞ÑÎã®Ìûà)
                        if (parsed.walls && parsed.rooms) {
                            reset(parsed);
                        }
                    } catch (e) {
                        console.error("Failed to load saved data", e);
                    }
                }
            }, []); // Mount Ïãú 1Ìöå Ïã§Ìñâ

            // 3. ÌååÏùº Îã§Ïö¥Î°úÎìú Ìï∏Îì§Îü¨
            const handleFileDownload = () => {
                const data = { walls, rooms, openings, furniture, timestamp: Date.now() };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `floor-plan-${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            // 4. ÌååÏùº ÏóÖÎ°úÎìú Ìï∏Îì§Îü¨
            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const parsed = JSON.parse(event.target.result);
                        if (parsed.walls && parsed.rooms) {
                            reset({
                                walls: parsed.walls || [],
                                rooms: parsed.rooms || [],
                                openings: parsed.openings || [],
                                furniture: parsed.furniture || []
                            });
                            alert("ÌååÏùºÏùÑ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î∂àÎü¨ÏôîÏäµÎãàÎã§.");
                        } else {
                            alert("Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏùÄ ÌååÏùº ÌòïÏãùÏûÖÎãàÎã§.");
                        }
                    } catch (err) {
                        console.error(err);
                        alert("ÌååÏùºÏùÑ ÏùΩÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
                    }
                };
                reader.readAsText(file);
                // Í∞ôÏùÄ ÌååÏùºÏùÑ Îã§Ïãú ÏÑ†ÌÉùÌï† Ïàò ÏûàÎèÑÎ°ù value Ï¥àÍ∏∞Ìôî
                e.target.value = '';
            };

            // ÌôîÎ©¥ Ï¢åÌëú -> ÏõîÎìú Ï¢åÌëú Î≥ÄÌôò
            const screenToWorld = (sx, sy) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const x = (sx - rect.left - pan.x) / scale;
                const y = (sy - rect.top - pan.y) / scale;
                return { x, y };
            };

            // Ïä§ÎßàÌä∏ Ïä§ÎÉÖ Ìï®Ïàò
            const getSnappedPosition = (x, y) => {
                let sx = snapToGrid(x);
                let sy = snapToGrid(y);
                const SNAP_DIST = 15 / scale; // Ïä§ÎÉÖ Í∞êÏßÄ Í±∞Î¶¨ (ÌôîÎ©¥ ÌîΩÏÖÄ Í∏∞Ï§Ä 15px)

                const newGuides = [];
                let snappedX = false;
                let snappedY = false;

                // Ï∞∏Ï°∞Ìï† Ìè¨Ïù∏Ìä∏ ÏàòÏßë (Î≤ΩÏùò Ïñë ÎÅùÏ†ê)
                const points = [];
                walls.forEach(w => {
                    points.push(w.start);
                    points.push(w.end);
                });
                rooms.forEach(r => {
                    r.points.forEach(p => points.push(p));
                });

                // 1. Vertex Snapping (Ï†ê Ïä§ÎÉÖ) - Í∞ÄÏû• Í∞ïÎ†•Ìïú Ïä§ÎÉÖ
                // Í∏∞Ï°¥ Ï†êÏóê Í∞ÄÍπåÏö∞Î©¥ Í∑∏ Ï†êÏúºÎ°ú Í∞ïÏ†ú Ïù¥Îèô (Ï§å ÏïÑÏõÉ ÏÉÅÌÉúÏóêÏÑúÎèÑ ÏâΩÍ≤å Ïó∞Í≤∞ Í∞ÄÎä•)
                for (const p of points) {
                    const dist = Math.sqrt(Math.pow(p.x - x, 2) + Math.pow(p.y - y, 2));
                    if (dist < SNAP_DIST) {
                        return { x: p.x, y: p.y, guides: [] }; // Í∞ÄÏù¥Îìú ÏóÜÏù¥ Î∞îÎ°ú Ïä§ÎÉÖ
                    }
                }

                // 2. Alignment Snapping (Ï†ïÎ†¨ Ïä§ÎÉÖ)
                // XÏ∂ï Ïä§ÎÉÖ (ÏàòÏßÅÏÑ† Í∞ÄÏù¥Îìú) - Îã§Î•∏ Ï†êÏùò XÏ¢åÌëúÏôÄ ÏùºÏπò
                for (const p of points) {
                    if (Math.abs(p.x - x) < SNAP_DIST) {
                        sx = p.x;
                        snappedX = true;
                        newGuides.push({ type: 'x', pos: sx, start: Math.min(y, p.y), end: Math.max(y, p.y) });
                        break; // ÌïòÎÇòÎßå Ïä§ÎÉÖ
                    }
                }

                // YÏ∂ï Ïä§ÎÉÖ (ÏàòÌèâÏÑ† Í∞ÄÏù¥Îìú) - Îã§Î•∏ Ï†êÏùò YÏ¢åÌëúÏôÄ ÏùºÏπò
                for (const p of points) {
                    if (Math.abs(p.y - y) < SNAP_DIST) {
                        sy = p.y;
                        snappedY = true;
                        newGuides.push({ type: 'y', pos: sy, start: Math.min(x, p.x), end: Math.max(x, p.x) });
                        break;
                    }
                }

                return { x: sx, y: sy, guides: newGuides };
            };

            // Ï∫îÎ≤ÑÏä§ Î†åÎçîÎßÅ
            useEffect(() => {
                if (mode !== '2D') return;

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');

                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight - 80;

                // Î∞∞Í≤Ω
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.save();

                // Ï§å & Ìå¨ Ï†ÅÏö©
                ctx.translate(pan.x, pan.y);
                ctx.scale(scale, scale);

                // Í∑∏Î¶¨Îìú Í∑∏Î¶¨Í∏∞
                const startX = Math.floor(-pan.x / scale / VISUAL_GRID_SIZE) * VISUAL_GRID_SIZE;
                const startY = Math.floor(-pan.y / scale / VISUAL_GRID_SIZE) * VISUAL_GRID_SIZE;
                const endX = startX + (canvas.width / scale) + VISUAL_GRID_SIZE;
                const endY = startY + (canvas.height / scale) + VISUAL_GRID_SIZE;

                ctx.beginPath();
                ctx.strokeStyle = "#e5e7eb";
                ctx.lineWidth = 1 / scale;

                for (let x = startX; x <= endX; x += VISUAL_GRID_SIZE) {
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, endY);
                }
                for (let y = startY; y <= endY; y += VISUAL_GRID_SIZE) {
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                }
                ctx.stroke();

                // 1. Î∞© Í∑∏Î¶¨Í∏∞
                rooms.forEach(room => drawRoom(ctx, room.points));
                if (currentRoom.length > 0) {
                    drawRoom(ctx, currentRoom, true);
                    ctx.beginPath();
                    ctx.strokeStyle = "blue";
                    ctx.setLineDash([5 / scale, 5 / scale]);
                    ctx.lineWidth = 2 / scale;
                    ctx.moveTo(currentRoom[currentRoom.length - 1].x, currentRoom[currentRoom.length - 1].y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // 2. Î≤Ω Í∑∏Î¶¨Í∏∞
                walls.forEach(wall => drawWall(ctx, wall, 'black'));
                if (currentWall) drawWall(ctx, currentWall, 'red', true);

                // 3. Ïò§ÌîÑÎãù Í∑∏Î¶¨Í∏∞
                openings.forEach(op => drawOpening(ctx, op, walls));
                if (previewOpening) drawOpening(ctx, previewOpening, walls, true);

                // 4. Í∞ÄÍµ¨ Í∑∏Î¶¨Í∏∞
                furniture.forEach(item => {
                    // ÎìúÎûòÍ∑∏ Ï§ëÏù∏ Í∞ÄÍµ¨Îäî Í∑∏Î¶¨ÏßÄ ÏïäÏùå (previewFurnitureÎ°ú Í∑∏Î†§Ïßê)
                    if (isDraggingFurniture && item.id === selectedFurnitureId) return;
                    drawFurniture(ctx, item);
                });
                if (previewFurniture) drawFurniture(ctx, previewFurniture, true);

                // 5. Ïä§ÎßàÌä∏ Í∞ÄÏù¥Îìú Í∑∏Î¶¨Í∏∞
                if (guides.length > 0) {
                    ctx.beginPath();
                    ctx.strokeStyle = "#ec4899"; // Pink-500
                    ctx.lineWidth = 1 / scale;
                    ctx.setLineDash([4 / scale, 4 / scale]);
                    guides.forEach(g => {
                        if (g.type === 'x') {
                            ctx.moveTo(g.pos, -10000); // ÌôîÎ©¥ Ï†ÑÏ≤¥Î•º Í∞ÄÎ°úÏßÄÎ•¥ÎèÑÎ°ù
                            ctx.lineTo(g.pos, 10000);
                        } else {
                            ctx.moveTo(-10000, g.pos);
                            ctx.lineTo(10000, g.pos);
                        }
                    });
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.restore();

            }, [walls, rooms, openings, furniture, currentWall, currentRoom, previewOpening, previewFurniture, mode, scale, pan, guides]);

            const drawRoom = (ctx, points, isPreview = false) => {
                if (points.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                if (!isPreview) ctx.closePath();

                ctx.fillStyle = isPreview ? "rgba(59, 130, 246, 0.2)" : "rgba(224, 231, 255, 0.5)";
                ctx.fill();
                ctx.strokeStyle = isPreview ? "blue" : "#a5b4fc";
                ctx.lineWidth = 2 / scale;
                ctx.stroke();

                points.forEach(p => {
                    ctx.beginPath();
                    ctx.fillStyle = "blue";
                    ctx.arc(p.x, p.y, 3 / scale, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Î∞© ÏπòÏàòÏÑ† ÌëúÏãú (Í∞Å Î≥ÄÏùò Í∏∏Ïù¥)
                if (points.length > 1) {
                    ctx.fillStyle = "#6b7280";
                    ctx.font = `${10 / scale}px sans-serif`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";

                    for (let i = 0; i < (isPreview ? points.length - 1 : points.length); i++) {
                        const p1 = points[i];
                        const p2 = points[(i + 1) % points.length];
                        const dist = distance(p1, p2);
                        if (dist > 20) {
                            const midX = (p1.x + p2.x) / 2;
                            const midY = (p1.y + p2.y) / 2;
                            ctx.fillText(`${Math.round(dist)}`, midX, midY);
                        }
                    }
                }
            };

            const drawWall = (ctx, wall, color, isGuide = false) => {
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = (isGuide ? 2 : 4) / scale;
                ctx.lineCap = "round";
                ctx.moveTo(wall.start.x, wall.start.y);
                ctx.lineTo(wall.end.x, wall.end.y);
                ctx.stroke();

                ctx.fillStyle = "#3b82f6";
                ctx.beginPath();
                ctx.arc(wall.start.x, wall.start.y, 4 / scale, 0, Math.PI * 2);
                ctx.arc(wall.end.x, wall.end.y, 4 / scale, 0, Math.PI * 2);
                ctx.fill();

                const dx = wall.end.x - wall.start.x;
                const dy = wall.end.y - wall.start.y;
                const len = Math.sqrt(dx * dx + dy * dy);

                if (len > 5) {
                    const midX = (wall.start.x + wall.end.x) / 2;
                    const midY = (wall.start.y + wall.end.y) / 2;

                    ctx.save();
                    ctx.translate(midX, midY);

                    let angle = Math.atan2(dy, dx);
                    if (angle > Math.PI / 2) angle -= Math.PI;
                    else if (angle < -Math.PI / 2) angle += Math.PI;

                    ctx.rotate(angle);

                    const fontSize = Math.max(12 / scale, 8);
                    ctx.font = `bold ${fontSize}px sans-serif`;
                    ctx.fillStyle = "#4b5563";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "bottom";

                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 3 / scale;
                    const text = Math.round(len) + " cm";
                    ctx.strokeText(text, 0, -4 / scale);
                    ctx.fillText(text, 0, -4 / scale);

                    ctx.restore();
                }
            };

            const drawOpening = (ctx, op, walls, isPreview = false) => {
                const wall = walls[op.wallIndex];
                if (!wall) return;

                const dx = wall.end.x - wall.start.x;
                const dy = wall.end.y - wall.start.y;

                const cx = wall.start.x + dx * op.t;
                const cy = wall.start.y + dy * op.t;

                const angle = Math.atan2(dy, dx);
                const width = op.type === 'door' ? DOOR_WIDTH : (op.type === 'balcony' ? BALCONY_WIDTH : WINDOW_WIDTH);

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angle);

                ctx.fillStyle = "white";
                ctx.fillRect(-width / 2, -4 / scale, width, 8 / scale);

                ctx.strokeStyle = isPreview ? "red" : "brown";
                ctx.lineWidth = 2 / scale;

                if (op.type === 'door') {
                    ctx.beginPath();
                    ctx.arc(-width / 2, -width / 2, width, 0, Math.PI / 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-width / 2, 0);
                    ctx.lineTo(-width / 2, -width);
                    ctx.stroke();
                } else {
                    ctx.strokeRect(-width / 2, -2 / scale, width, 4 / scale);
                    ctx.fillStyle = "#bae6fd";
                    ctx.fillRect(-width / 2, -2 / scale, width, 4 / scale);

                    // Î∞úÏΩîÎãàÎäî Ï§ëÍ∞ÑÏóê ÏÑ† Ï∂îÍ∞Ä (Ïä¨ÎùºÏù¥Îî© ÎèÑÏñ¥ ÎäêÎÇå)
                    if (op.type === 'balcony') {
                        ctx.beginPath();
                        ctx.moveTo(0, -2 / scale);
                        ctx.lineTo(0, 2 / scale);
                        ctx.stroke();
                    }
                }

                ctx.restore();
            };

            const drawFurniture = (ctx, item, isPreview = false) => {
                const template = FURNITURE_TEMPLATES[item.type];
                if (!template) return;

                const isSelected = item.id === selectedFurnitureId;

                ctx.save();
                ctx.translate(item.x, item.y);
                ctx.rotate(item.rotation);

                const { width, depth, label } = template;

                ctx.beginPath();
                ctx.rect(-width / 2, -depth / 2, width, depth);

                ctx.fillStyle = isPreview ? "rgba(100, 100, 100, 0.5)" : (isSelected ? "#bfdbfe" : "#e5e7eb"); // ÏÑ†ÌÉù Ïãú Ïó∞Ìïú ÌååÎûÄÏÉâ
                ctx.fill();
                ctx.strokeStyle = isPreview ? "blue" : (isSelected ? "#2563eb" : "#4b5563"); // ÏÑ†ÌÉù Ïãú ÏßÑÌïú ÌååÎûÄÏÉâ
                ctx.lineWidth = (isSelected ? 3 : 2) / scale;
                ctx.stroke();

                // ÏÑ†ÌÉùÎêú Í≤ΩÏö∞ Î™®ÏÑúÎ¶¨ Ìï∏Îì§ ÌëúÏãú (ÏãúÍ∞ÅÏ†Å Ìö®Í≥ºÎßå)
                if (isSelected) {
                    ctx.fillStyle = "#2563eb";
                    const handleSize = 6 / scale;
                    ctx.fillRect(-width / 2 - handleSize / 2, -depth / 2 - handleSize / 2, handleSize, handleSize);
                    ctx.fillRect(width / 2 - handleSize / 2, -depth / 2 - handleSize / 2, handleSize, handleSize);
                    ctx.fillRect(width / 2 - handleSize / 2, depth / 2 - handleSize / 2, handleSize, handleSize);
                    ctx.fillRect(-width / 2 - handleSize / 2, depth / 2 - handleSize / 2, handleSize, handleSize);
                }

                // Î∞©Ìñ• ÌëúÏãú (ÏïûÏ™Ω)
                ctx.beginPath();
                ctx.moveTo(-width / 4, depth / 2 - 5);
                ctx.lineTo(width / 4, depth / 2 - 5);
                ctx.stroke();

                // ÌÖçÏä§Ìä∏
                ctx.fillStyle = "#000";
                ctx.font = `${12 / scale}px sans-serif`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.save();
                ctx.rotate(-item.rotation); // ÌÖçÏä§Ìä∏Îäî Ï†ïÎ∞©Ìñ• Ïú†ÏßÄ
                ctx.fillText(label, 0, 0);
                ctx.restore();

                ctx.restore();
            };

            const handleWheel = (e) => {
                if (mode !== '2D') return;
                e.preventDefault();

                const zoomSensitivity = 0.001;
                const delta = -e.deltaY * zoomSensitivity;
                const newScale = Math.min(Math.max(0.1, scale + delta), 5);

                const rect = canvasRef.current.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const worldX = (mouseX - pan.x) / scale;
                const worldY = (mouseY - pan.y) / scale;

                const newPanX = mouseX - worldX * newScale;
                const newPanY = mouseY - worldY * newScale;

                setScale(newScale);
                setPan({ x: newPanX, y: newPanY });
            };

            const handleMouseDown = (e) => {
                if (mode !== '2D') return;

                if (e.button === 1 || e.button === 2 || (e.button === 0 && e.shiftKey)) {
                    setIsPanning(true);
                    setLastMousePos({ x: e.clientX, y: e.clientY });
                    return;
                }

                const worldPos = screenToWorld(e.clientX, e.clientY);
                // ÎßàÏö∞Ïä§ Îã§Ïö¥ ÏãúÏóêÎèÑ Ïä§ÎÉÖ Ï†ÅÏö© (ÏãúÏûëÏ†ê Ïä§ÎÉÖ)
                const snapped = getSnappedPosition(worldPos.x, worldPos.y);
                const x = snapped.x;
                const y = snapped.y;

                if (tool === 'select') {
                    // Í∞ÄÍµ¨ ÏÑ†ÌÉù Î°úÏßÅ (MouseDownÏóêÏÑú Ï≤òÎ¶¨)
                    let clickedFurnitureId = null;
                    for (let i = furniture.length - 1; i >= 0; i--) {
                        const item = furniture[i];
                        const template = FURNITURE_TEMPLATES[item.type];
                        if (!template) continue;

                        const dx = worldPos.x - item.x;
                        const dy = worldPos.y - item.y;

                        // Ï†êÏùÑ Í∞ÄÍµ¨Ïùò Î°úÏª¨ Ï¢åÌëúÍ≥ÑÎ°ú Î≥ÄÌôò (ÌöåÏ†Ñ Í≥†Î†§)
                        const cos = Math.cos(-item.rotation);
                        const sin = Math.sin(-item.rotation);
                        const localX = dx * cos - dy * sin;
                        const localY = dx * sin + dy * cos;

                        if (Math.abs(localX) <= template.width / 2 && Math.abs(localY) <= template.depth / 2) {
                            clickedFurnitureId = item.id;
                            break;
                        }
                    }

                    if (clickedFurnitureId) {
                        setSelectedFurnitureId(clickedFurnitureId);
                        setIsDraggingFurniture(true);
                        // ÎìúÎûòÍ∑∏ ÏãúÏûë Ïãú ÎØ∏Î¶¨Î≥¥Í∏∞ ÏÑ§Ï†ï (ÏÑ†ÌÉùÏ†Å)
                        const item = furniture.find(f => f.id === clickedFurnitureId);
                        setPreviewFurniture({ ...item });
                    } else {
                        setSelectedFurnitureId(null);
                    }
                } else if (tool === 'wall') {
                    setCurrentWall({ start: { x, y }, end: { x, y } });
                } else if (tool === 'room') {
                    setCurrentRoom([{ x, y }, { x, y }, { x, y }, { x, y }]);
                } else if (tool === 'door' || tool === 'window' || tool === 'balcony') {
                    if (previewOpening) {
                        pushState({
                            ...state,
                            openings: [...openings, previewOpening]
                        });
                        setPreviewOpening(null);
                    }
                } else if (FURNITURE_TEMPLATES[tool]) {
                    if (previewFurniture) {
                        pushState({
                            ...state,
                            furniture: [...furniture, { ...previewFurniture, id: Date.now() }]
                        });
                    }
                }
            };

            const handleMouseMove = (e) => {
                if (mode !== '2D') return;

                if (isPanning) {
                    const dx = e.clientX - lastMousePos.x;
                    const dy = e.clientY - lastMousePos.y;
                    setPan(prev => ({ x: prev.x + dx, y: prev.y + dy }));
                    setLastMousePos({ x: e.clientX, y: e.clientY });
                    return;
                }

                const worldPos = screenToWorld(e.clientX, e.clientY);

                // Ïä§ÎßàÌä∏ Ïä§ÎÉÖ Ï†ÅÏö©
                const snapped = getSnappedPosition(worldPos.x, worldPos.y);
                const x = snapped.x;
                const y = snapped.y;

                // Í∞ÄÏù¥ÎìúÎùºÏù∏ ÏóÖÎç∞Ïù¥Ìä∏ (Î≤ΩÏù¥ÎÇò Î∞© Í∑∏Î¶¨Í∏∞ ÎèÑÍµ¨Ïùº ÎïåÎßå)
                if (tool === 'wall' || tool === 'room') {
                    setGuides(snapped.guides);
                } else {
                    setGuides([]);
                }

                if (tool === 'wall' && currentWall) {
                    let targetX = x;
                    let targetY = y;

                    // Shift ÌÇ§Î•º ÎàÑÎ•¥Î©¥ ÏàòÏßÅ/ÏàòÌèâ Í≥†Ï†ï
                    if (e.shiftKey) {
                        const dx = Math.abs(x - currentWall.start.x);
                        const dy = Math.abs(y - currentWall.start.y);
                        if (dx > dy) {
                            targetY = currentWall.start.y;
                        } else {
                            targetX = currentWall.start.x;
                        }
                    }
                    setCurrentWall(prev => ({ ...prev, end: { x: targetX, y: targetY } }));
                } else if (tool === 'room' && currentRoom.length > 0) {
                    const start = currentRoom[0];
                    const end = { x, y };
                    const newPoints = [
                        start,
                        { x: end.x, y: start.y },
                        end,
                        { x: start.x, y: end.y }
                    ];
                    setCurrentRoom(newPoints);
                } else if (tool === 'door' || tool === 'window' || tool === 'balcony') {
                    let minDist = 20 / scale;
                    let nearest = null;

                    walls.forEach((wall, idx) => {
                        const proj = projectPointOnLine({ x: worldPos.x, y: worldPos.y }, wall.start, wall.end);
                        const d = distance({ x: worldPos.x, y: worldPos.y }, proj);
                        if (d < minDist) {
                            minDist = d;
                            nearest = { wall, idx, t: proj.t };
                        }
                    });

                    if (nearest) {
                        setPreviewOpening({
                            type: tool,
                            wallIndex: nearest.idx,
                            t: nearest.t,
                            width: tool === 'door' ? DOOR_WIDTH : (tool === 'balcony' ? BALCONY_WIDTH : WINDOW_WIDTH),
                            height: tool === 'door' ? DOOR_HEIGHT : (tool === 'balcony' ? BALCONY_HEIGHT : WINDOW_HEIGHT)
                        });
                    } else {
                        setPreviewOpening(null);
                    }
                } else if (FURNITURE_TEMPLATES[tool]) {
                    setPreviewFurniture(prev => ({
                        type: tool,
                        x,
                        y,
                        rotation: prev ? prev.rotation : 0
                    }));
                } else if (tool === 'select' && isDraggingFurniture && selectedFurnitureId) {
                    // Í∞ÄÍµ¨ Ïù¥Îèô Ï§ë ÎØ∏Î¶¨Î≥¥Í∏∞ ÏóÖÎç∞Ïù¥Ìä∏
                    setPreviewFurniture({
                        ...furniture.find(f => f.id === selectedFurnitureId),
                        x, y
                    });
                }
            };

            const handleMouseUp = () => {
                if (mode !== '2D') return;

                if (isPanning) {
                    setIsPanning(false);
                    return;
                }

                if (tool === 'wall' && currentWall) {
                    if (currentWall.start.x !== currentWall.end.x || currentWall.start.y !== currentWall.end.y) {
                        pushState({
                            ...state,
                            walls: [...walls, currentWall]
                        });
                    }
                    setCurrentWall(null);
                } else if (tool === 'room' && currentRoom.length > 0) {
                    if (currentRoom[0].x !== currentRoom[2].x || currentRoom[0].y !== currentRoom[2].y) {
                        pushState({
                            ...state,
                            rooms: [...rooms, { points: currentRoom }]
                        });
                    }
                    setCurrentRoom([]);
                } else if (tool === 'select' && isDraggingFurniture && selectedFurnitureId && previewFurniture) {
                    // ÎìúÎûòÍ∑∏ Ï¢ÖÎ£å: Î≥ÄÍ≤ΩÎêú ÏúÑÏπò Î∞è ÌöåÏ†Ñ Ï†ÄÏû•
                    const updatedFurniture = furniture.map(f =>
                        f.id === selectedFurnitureId ? { ...f, x: previewFurniture.x, y: previewFurniture.y, rotation: previewFurniture.rotation } : f
                    );
                    pushState({
                        ...state,
                        furniture: updatedFurniture
                    });
                    setIsDraggingFurniture(false);
                    setPreviewFurniture(null);
                }
            };

            const handleDoubleClick = () => { };

            const clearAll = () => {
                if (confirm("Ï†ïÎßê Î™®Îëê ÏßÄÏö∞ÏãúÍ≤†ÏäµÎãàÍπå?")) {
                    reset({ walls: [], rooms: [], openings: [], furniture: [] });
                    setCurrentWall(null);
                    setCurrentRoom([]);
                    setPreviewOpening(null);
                    setPreviewFurniture(null);
                    setScale(1);
                    setPan({ x: 0, y: 0 });
                }
            };

            return (
                <div className="flex flex-col h-screen relative" onContextMenu={(e) => e.preventDefault()}>
                    <Toolbar
                        tool={tool}
                        setTool={setTool}
                        undo={undo}
                        redo={redo}
                        canUndo={canUndo}
                        canRedo={canRedo}
                        clearAll={clearAll}
                        mode={mode}
                        setMode={setMode}
                        handleFileDownload={handleFileDownload}
                        handleFileUpload={handleFileUpload}
                    />

                    <div className="flex-1 relative overflow-hidden">
                        {mode === '2D' ? (
                            <div className="w-full h-full bg-white cursor-crosshair">
                                <canvas
                                    ref={canvasRef}
                                    onMouseDown={handleMouseDown}
                                    onMouseMove={handleMouseMove}
                                    onMouseUp={handleMouseUp}
                                    onDoubleClick={handleDoubleClick}
                                    onWheel={handleWheel}
                                    className="block"
                                />
                                <div className="absolute top-6 left-6 bg-white/90 backdrop-blur-md p-4 rounded-2xl shadow-lg border border-white/50 max-w-xs transition-all duration-300 pointer-events-none z-20">
                                    <div className="flex items-center space-x-2 mb-2">
                                        <span className="text-2xl">{TOOLS.find(t => t.id === tool)?.icon || FURNITURE_TOOLS.find(t => t.id === tool)?.icon || 'üëÜ'}</span>
                                        <h3 className="font-bold text-gray-800 text-sm">
                                            {TOOLS.find(t => t.id === tool)?.label || FURNITURE_TOOLS.find(t => t.id === tool)?.label || 'ÏÑ†ÌÉù Î™®Îìú'}
                                        </h3>
                                    </div>
                                    <p className="text-xs text-gray-600 leading-relaxed">
                                        {tool === 'select' && "Í∞ùÏ≤¥Î•º ÌÅ¥Î¶≠ÌïòÏó¨ ÏÑ†ÌÉùÌïòÍ±∞ÎÇò ÎìúÎûòÍ∑∏ÌïòÏó¨ Ïù¥ÎèôÌïòÏÑ∏Ïöî."}
                                        {tool === 'wall' && "ÎßàÏö∞Ïä§Î•º ÎìúÎûòÍ∑∏ÌïòÏó¨ Î≤ΩÏùÑ Í∑∏Î¶¨ÏÑ∏Ïöî. ShiftÎ•º ÎàÑÎ•¥Î©¥ ÏàòÏßÅ/ÏàòÌèâÏúºÎ°ú Í≥†Ï†ïÎê©ÎãàÎã§."}
                                        {tool === 'room' && "ÎìúÎûòÍ∑∏ÌïòÏó¨ ÏÇ¨Í∞ÅÌòï Î∞©ÏùÑ ÎßåÎìúÏÑ∏Ïöî."}
                                        {(tool === 'door' || tool === 'window' || tool === 'balcony') && "Î≤Ω ÏúÑÏóê ÎßàÏö∞Ïä§Î•º Ïò¨Î†§ Î∞∞ÏπòÌïòÏÑ∏Ïöî."}
                                        {FURNITURE_TEMPLATES[tool] && "ÏõêÌïòÎäî ÏúÑÏπòÏóê ÌÅ¥Î¶≠ÌïòÏó¨ Î∞∞ÏπòÌïòÏÑ∏Ïöî."}
                                    </p>
                                    <div className="mt-3 pt-3 border-t border-gray-100 grid grid-cols-2 gap-2 text-[10px] text-gray-500">
                                        <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">üñ±Ô∏è</span> Ïù¥Îèô/Ï§å</div>
                                        {FURNITURE_TEMPLATES[tool] && <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">R</span> ÌöåÏ†Ñ</div>}
                                        <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">‚å´</span> ÏÇ≠Ï†ú</div>
                                        <div className="flex items-center"><span className="w-4 h-4 bg-gray-100 rounded flex items-center justify-center mr-1">Esc</span> Ï∑®ÏÜå</div>
                                    </div>
                                </div>
                            </div>
                        ) : (
                            <Viewer3D walls={walls} rooms={rooms} openings={openings} furniture={furniture} />
                        )}
                        <HelpButton />
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
        // v1.1
    </script>
</body>

</html>